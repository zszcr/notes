## Java基础知识



### 基本数据类型

**基本数据类型**

Java一共有8种基本数据类型：

* boolean  布尔型
* byte   字节类型
* char    字符类型
* short   短整形
* int       整形
* float     浮点型（单精度）
* long     长整形
* double 双精度类型

其中Java默认的整数类型为int，如果需要定义为long，则需要在数值后面加上L或者l

默认的浮点型是双精度的。同时Java中char类型占用的内存空间为2个字节，它除了可以表示标准的ASCII外，它还可以表示一个Unicode字符。在Java中的boolean类型占用的内存空间是不确定的，它有两个可能的值：true和false，但是它的”大小“不是一个精确的值。



Java中整形类型能表示的范围：

- byte：-128 ~ 127
- short: -32768 ~ 32767
- int: -2147483648 ~ 2147483647
- long: -9223372036854775808 ~ 9223372036854775807



**引用类型**

Java中除了上面的基本类型外，剩下的都是引用类型。例如，引用类型最常用的就是String字符串：

```java
String s ="test";
```

引用类型类似C++的指针，它内部中存储一个"地址"，指向某个对象的内存位置。



**常量**

Java在定义变量时，如果加上`final`修饰符，那么这个变量就变成了常量

```java
final int MAXSIZE = 0x1000; //MAXSIZE是一个常量
int size = 100;
```

常量在定义时进行初始化，并且之后不能再次进行赋值，再次赋值会导致编译错误。常量的作用是用有意义的变量名来避免魔术数字，例如在代码中使用一个常量PI来代替3.14。根据习惯，常量名通常全大写



**var关键字**

var关键字用于定义变量，当类型名太长时，想省略掉它，就可以使用var

```java
StringBuilder s = new StringBuilder();
var x = new StringBuilder();
```

编译器会根据赋值语句自动推断出变量x的类型





### 运算符

基本分类：

* 算数运算符

  > 包括加减乘除和自增及自检
  >
  > `+-*\` 和 `++` 及`--`
  >
  > 其中**前缀自增自减法(++a,--a):** 先进行自增或者自减运算，再进行表达式运算。
  >
  > **后缀自增自减法(a++,a--):** 先进行表达式运算，再进行自增或者自减运算 实例：

* 关系运算符

  * ==

    判断两操作数是否相等，如果相等的话就返回true

  * !=

    判断两个数是否相等，如果不相等的话就返回true

  * `>`

    判断左操作数是否大于右操作数，如果是就返回true

  * `<`

    判断右操作数是否大于左操作数，如果是就返回true

  * `>=`

    判断左操作数是否大于或等于右操作数，如果是就返回true

  * `<=`

    判断右操作数是否大于或等于左操作数 ，如果是就返回true

* 位运算符

  位运算符用于int \ long\ short\char\byte等类型

  demo:

  ```
  A = 0001 0001
  B = 1010 1011
  A&B = 0000 0001
  A|B = 1011 1011
  A^B = 1011 1010
  ~A = 1110 1110
  A<<2 = 0100 0100
  A>>2 = 0100
  A>>>2 = 0000 0100
  ```

  | 操作符 | 描述                                                         |
  | ------ | ------------------------------------------------------------ |
  | \|     | 如果相对应位都是0，则结果为0，否则为1                        |
  | ^      | 如果相对应位值相同，则结果为0，否则为1                       |
  | ~      | 按位取反，即0变1 ，1变0                                      |
  | <<     | 按位左移，左操作数按位向左移右操作数指定的位数               |
  | >>     | 按位右移，左操作数按位向右移右操作数指定的位数               |
  | >>>    | 按位右移补零操作符，左操作数的值按右操作数指定的位数右移，移动得到的空位用0填补 |
  | &      | 如果对应位都是1，则结果为1，否则为0                          |

* 逻辑运算符

  * && 

    逻辑与运算符，当且仅当两个操作数都为真时，条件才为真

    当使用逻辑与运算符时，如果第一个操作数得到false，那么其结果必定为false，它会跳过第二个操作数的判断

  * || 

    逻辑或操作符，任一操作数为真时，条件为真

  * !

    逻辑非运算符，用来反转操作数的逻辑状态

* 赋值运算符

  | 操作符  | 描述                                                         | 例子                                     |
  | :------ | :----------------------------------------------------------- | :--------------------------------------- |
  | =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
  | + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
  | - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
  | * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
  | / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
  | （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
  | << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
  | >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
  | ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
  | ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
  | \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

* 其他运算符

  * 条件运算符 `?:`

    表达式为：

    ```java
    variable x = (expression) ? value if true : value if false
    ```

    例子：

    ```java
    a = 10;
    b = (a > 1)? 2 : 3;
    ```

  * instanceof 运算符

    这个运算符用于操作对象实例，检查该对象是否是一个特定的类型

    使用格式：

    ```
    ( Object reference variable ) instanceof  (class/interface type)
    ```

    例子:

    ```java
    String name = "James";
    boolean result = name instanceof String; // 由于name是String类型，所以返回真
    ```



**运算符的优先级**

| 类别     | 操作符                                     | 关联性   |
| :------- | :----------------------------------------- | :------- |
| 后缀     | () [] . (点操作符)                         | 左到右   |
| 一元     | expr++ expr--                              | 从左到右 |
| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | > >= < <=                                  | 左到右   |
| 相等     | == !=                                      | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |



### 修饰符

修饰符用于定义类、方法或者变量，通常放在语句的最前端

#### 访问控制修饰符

Java中，使用访问控制修饰符来保护类、变量、方法和构造方法的访问，它一共支持4种不同的访问权限

* default（默认，什么也不写）：在同一个包内可见，不适用任何修饰符。
* private：在同一个类可见。使用对象：变量、方法（注意不能用来修饰类）
* public：对所有类可见。使用对象：类、接口、变量、方法
* protected：对同一个包内的类和所有子类可见，使用对象：变量、方法。（注意不能修饰类）

访问权限如下：

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
| `default`   | Y      | Y        | Y              | N                                                            | N      |
| `private`   | Y      | N        | N              | N                                                            | N      |



**默认访问修饰符**

使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 **public static final**,而接口里的方法默认情况下访问权限为 **public**。



**私有访问修饰符**

私有访问修饰符private是最严格的访问级别，所有被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。声明为private的变量只能通过类中的方法来获得。



**公有访问修饰符**

公有访问修饰符public，被声明为public的类、方法、构造方法和接口能够被任何其他类进行访问。

如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。



**受保护的访问修饰符**

受保护的访问修饰符protected要从两个方面分析

* 子类和基类在同一个包内

  被声明为protected的变量、方法和构造器能被同一个包内的任何其他类访问

* 子类和基类不在同一个包内

  在子类中，子类实例可以访问从基类继承而来的protected方法，而不能访问基类实例的protected方法

protected 可以修饰数据成员，构造方法，方法成员，**不能修饰类（内部类除外）**



**访问和控制**

继承规则：

* 父类中声明为 public 的方法在子类中也必须为 public。
* 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
* 父类中声明为 private 的方法，不能够被继承。



#### 非访问修饰符

#### static修饰符

static修饰符用于修饰类方法和类变量

- **静态变量：**

  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。

- **静态方法：**

  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。



#### final修饰符

**final变量**

final 修饰符通常和 static 修饰符一起使用来创建类常量，被final修饰的实例变量必须显示的指定初始值

**final方法**

父类中的final方法可以被子类继承，但是不能被子类重写。

声明final方法的主要目的是防止该方法的内容被改写

**final类**

final类不能被继承，没有类能够继承final类的任何特性



#### abstract修饰符

abstract修饰符可以用来修饰类和方法

**抽象类**

抽象类不能用于实例化对象，声明抽象类的唯一目的就是对该类进行扩充。

一个类不能同时被abstract和final修饰。如果一个类中包含抽象方法，那么该类一定要修饰为抽象类。

**抽象方法**

抽象方法是一种没有任何实现的方法，这个方法的具体实现有子类提供。

抽象方法不能被声明为final和static

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。

抽象方法的声明以分号结尾，例如：**public abstract sample();**。



#### synchronized修饰符

synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。



#### transient 修饰符

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。



#### volatile 修饰符

volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值





### 控制语句

#### 循环结构

* while循环

  基本结构：

  ```java
  while (expression){
  	//循环内容
  }
  ```

  只要expression为true就会一直执行下去

  demo:

  ```java
  int x = 0;
  while (x < 10) {
        x++;
       System.out.print(x);
  }
  ```

* do...while循环

  do...while循环和while循环相似，不同的是do..while循环至少会执行一次，而while循环如果表达式不满足条件的话就不能进入循环

  基本结构：

  ```java
  do{
  	//循环内容
  }while(expression);
  ```

  demo:

  ```java
  int x = 10;
  do{
      x++;
  	System.out.println(x);
  }while(x < 20);
  ```

* for 循环

  基本结构：

  ```
  for(初始话;布尔表达式;更新){
  	//循环内容
  }
  ```

  for循环最先执行初始化步骤，可以声明一种类型，可以初始化一个或多个循环控制变量，也可以是空语句。

  之后会检测布尔表达式的值，如果为true，循环体就会被执行，如果为false，循环就会停止

  执行一次循环后，就会更新循环控制变量

  demo:

  ```java
  for(int i=0; i<10; i++)
  {
      System.out.println(i);
  }
  ```

* 增强型for循环

  Java中引入了一种用于数组的增强型for循环，主要用于数组

  基本结构：

  ```java
  for(声明语句:表达式)
  {
      //代码主体
  }
  ```

  声明语句：声明新的局部变量，该变量的数据类型必须和数组类型匹配。其作用域限定为循环语句块内，它的值和当前的数组元素的值相等

  表达式：表达式是要访问的数组名，或者是返回值为数组的方法

  demo：

  ```java
  int []number = {0,1,2,3,4,5};
  for(int i : number){
  	System.out.println(i);
  }
  ```

* break和continue关键字

  break关键字用于跳出整个语句块，它会跳出最里层的循环，并继续执行改循环下的语句

  continue关键字的作用是让程序立刻跳转到下一次循环的迭代中，在 for 循环中，continue 语句使程序立即跳转到更新语句，在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。





#### 条件语句

* if语句

  一个if语句包含一个布尔表达式和一条或多条语句

  语法：

  ```java
  if(布尔表达式){
      //布尔表达式为true时要执行的代码语句
  }
  ```

* if ... else语句

  if语句后面可以跟else语句，当if语句为false时，else语句块就会被执行

  语法：

  ```java
  if(布尔表达式){
  	//布尔表达式为true时执行的代码语句
  }else{
      //布尔表达式为false时执行的语句
  }
  ```

* if ... else if ... else语句

  if语句后面可以跟else...if...else语句，这种语句可以检测到多种可能的情况

  * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。
  * f 语句可以有若干个 else if 语句，它们必须在 else 语句之前。
  * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。

  语法：

  ```java
  if(布尔表达式 1){
     //如果布尔表达式 1的值为true执行代码
  }else if(布尔表达式 2){
     //如果布尔表达式 2的值为true执行代码
  }else if(布尔表达式 3){
     //如果布尔表达式 3的值为true执行代码
  }else {
     //如果以上布尔表达式都不为true执行代码
  }
  ```



#### switch case语句

switch case语句用于判断一个变量与一系列变量中的某个值是否相等，每个值为一个分支

语法：

```java
switch(expression){
    case value:
        //语句
        break;//可选
    case value:
        //语句
        break; //可选
    default: //可选
        //语句
}
```



### Java方法

#### 命名规则

1. 方法的名字的第一个单词应该以小写开头，后面的单词则用大写字母开头，不使用连接符，例如：`addPersion`
2. 下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件，例如：`testPop_emptyStack`



#### 基本语法

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

* 修饰符：可选，告诉编译器如何调用该方法，定义了方法的访问类型
* 返回值类型：方法可能有返回值，如果没有返回值，那么返回值类型为void
* 方法名：就是方法的实际名称。方法和参数表共同构成方法签名
* 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。
* 方法体：方法体包含着具体的代码语句，用于实现方法的功能

**注意：** 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。



#### 方法重载

方法重载允许同时存在两个或多个相同方法名的方法，但是它们的参数必须不同

例如：

```java
public static double max(double x1,double x2)
{
}

public static int max (int x1,int x2)
{
}
```

如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；

如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；

Java编译器根据方法签名判断哪个方法应该被调用。



#### 构造方法

构造方法在一个对象被创建时调用，它的作用是初始化该对象。构造方法和它所在的类型相同，它没有返回值。

通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。

不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。

一旦你定义了自己的构造方法，默认构造方法就会失效。



#### 可变参数

方法的可变参数的声明如下所示：

```java
typeName... parameterName
```

在方法的声明中，在指定参数类型后面加一个省略号

一个方法只能指定一个可变参数，它必须是方法的最后一个参数，其他普通参数必须在它之前声明。

demo:

```java
public static void printMax(double... numbers){
    if(numbers.length==0)
    {
		System.out.println("no argument passed!");
    }
    
    double result = number[0];
	for(int i =1; i < numbers.length;i++)
    {
		if(numbers[i] > result)
        {
			result = numbers[i];
        }
        
    }
    
    System.out.println("max number is :" + result);
}

```



### 数组

Java用数组存储固定大小的同类型元素

数组变量的声明：

```java
dataType[] arrayRefVar;		
//或
dataType arrayRefVar[];
```

其中后者风格来自C/C++语言，两者的效果是相同的

创建数组：

```java
arrayRefVar = new dataType[arraysize];
```

数组变量的声明和创建可以使用一条语句完成

```java
dataType[] arrayRefVar = new dataType[arraysize];
```

数组成员的访问：

数组通过下标来访问数组中的元素

```java
System.out.println(arrayRefVar[0]);
```

* 基本循环

  可以是用基本for循环，或者是while循环等

* for-each循环

  for-each循环也叫加强型for循环

  ```java
  for(type element: array){
      System.out.println(element);
  }
  ```

  

### Java对象和类

Java是一种面向对象的语言，它支持以下基本概念：

- 多态
- 继承
- 封装
- 抽象
- 类
- 对象
- 实例
- 方法
- 重载

其中对象是类的一个实例，类相当于一个模板

Java通过关键字class来定义一个类，一个

**构造方法**

每个类都有构造方法，如果没有显示的为类定义构造方法，Java编译器会为该类提供一个默认的构造方法

在创建一个类的对象时，至少要调用一个构造方法。构造方法必须和类同名。

demo:

```java
public class Dog{
    public Dog()
    {

    }
	public Dog(String name)
    {
		System.out.println(name);
    }
}

```

**源文件声明规则**

* 一个源文件只能有一个public类
* 一个源文件可以有多个非public类
* 源文件的名称应该和public类的类名保持一致
* 如果一个类定义在某个包内，那么package语句应该再源文件的首行
* 如果源文件包含import语句，那么应该放在package语句和类定义之间，如果没有package语句，那么import语句应该位于源文件的首行
* import语句和package语句对源文件中定义的所有类都有效。



**创建对象**

对象是根据类来创建的。在Java中，使用关键字new来创建一个新的对象。创建对象主要步骤如下：

* 声明：声明一个对象，包括对象名称和对象类型
* 实例化：使用关键字new来创建一个对象
* 初始化：使用new创建对象时，会调用构造方法来初始化对象



**访问实例变量和方法**

可以通过已创建的对象方法来访问成员变量和成员方法，例如：

```java
/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
```





#### 继承

